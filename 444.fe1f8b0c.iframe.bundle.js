"use strict";(self.webpackChunkthe_next=self.webpackChunkthe_next||[]).push([[444],{"./node_modules/recoil/es/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{L4:()=>Recoil_index_22,bi:()=>Recoil_index_5,eU:()=>Recoil_index_8,vc:()=>Recoil_index_20});var _createMutableSource,_useMutableSource,_useSyncExternalStore,react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),react_dom__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react-dom/index.js"),process=__webpack_require__("./node_modules/process/browser.js"),err_1=function err(message){let error=Error(message);if(void 0===error.stack)try{throw error}catch(_){}return error},Recoil_isPromise=function isPromise(p){return!!p&&"function"==typeof p.then},Recoil_nullthrows=function nullthrows(x,message){if(null!=x)return x;throw err_1(null!=message?message:"Got unexpected null or undefined")};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class BaseLoadable{getValue(){throw err_1("BaseLoadable")}toPromise(){throw err_1("BaseLoadable")}valueMaybe(){throw err_1("BaseLoadable")}valueOrThrow(){throw err_1(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw err_1("BaseLoadable")}promiseOrThrow(){throw err_1(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw err_1("BaseLoadable")}errorOrThrow(){throw err_1(`Loadable expected error, but in "${this.state}" state`)}is(other){return other.state===this.state&&other.contents===this.contents}map(_map){throw err_1("BaseLoadable")}}class ValueLoadable extends BaseLoadable{constructor(value){super(),_defineProperty(this,"state","hasValue"),_defineProperty(this,"contents",void 0),this.contents=value}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(map){try{let next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):isLoadable(next)?next:loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next(()=>this.map(map))):loadableWithError(e)}}}class ErrorLoadable extends BaseLoadable{constructor(error){super(),_defineProperty(this,"state","hasError"),_defineProperty(this,"contents",void 0),this.contents=error}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(_map){return this}}class LoadingLoadable extends BaseLoadable{constructor(promise){super(),_defineProperty(this,"state","loading"),_defineProperty(this,"contents",void 0),this.contents=promise}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(map){return loadableWithPromise(this.contents.then(value=>{let next=map(value);if(isLoadable(next))switch(next.state){case"hasValue":case"loading":return next.contents;case"hasError":throw next.contents}return next}).catch(e=>{if(Recoil_isPromise(e))return e.then(()=>this.map(map).contents);throw e}))}}function loadableWithValue(value){return Object.freeze(new ValueLoadable(value))}function loadableWithError(error){return Object.freeze(new ErrorLoadable(error))}function loadableWithPromise(promise){return Object.freeze(new LoadingLoadable(promise))}function loadableLoading(){return Object.freeze(new LoadingLoadable(new Promise(()=>{})))}function loadableAllArray(inputs){return inputs.every(i=>"hasValue"===i.state)?loadableWithValue(inputs.map(i=>i.contents)):inputs.some(i=>"hasError"===i.state)?loadableWithError(Recoil_nullthrows(inputs.find(i=>"hasError"===i.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(inputs.map(i=>i.contents)))}function loadableAll(inputs){let output=loadableAllArray((Array.isArray(inputs)?inputs:Object.getOwnPropertyNames(inputs).map(key=>inputs[key])).map(x=>isLoadable(x)?x:Recoil_isPromise(x)?loadableWithPromise(x):loadableWithValue(x)));return Array.isArray(inputs)?output:output.map(outputs=>Object.getOwnPropertyNames(inputs).reduce((out,key,idx)=>({...out,[key]:outputs[idx]}),{}))}function isLoadable(x){return x instanceof BaseLoadable}var Recoil_Loadable={loadableWithValue,loadableWithError,loadableWithPromise,loadableLoading,loadableAll,isLoadable,RecoilLoadable:{of:value=>Recoil_isPromise(value)?loadableWithPromise(value):isLoadable(value)?value:loadableWithValue(value),error:error=>loadableWithError(error),loading:()=>loadableLoading(),all:loadableAll,isLoadable}},Recoil_Loadable$1=Object.freeze({__proto__:null,loadableWithValue:Recoil_Loadable.loadableWithValue,loadableWithError:Recoil_Loadable.loadableWithError,loadableWithPromise:Recoil_Loadable.loadableWithPromise,loadableLoading:Recoil_Loadable.loadableLoading,loadableAll:Recoil_Loadable.loadableAll,isLoadable:Recoil_Loadable.isLoadable,RecoilLoadable:Recoil_Loadable.RecoilLoadable});let env={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function readProcessEnvBooleanFlag(name,set){var _process$env$name,_process$env$name$toL;let sanitizedValue=null===(_process$env$name=process.env[name])||void 0===_process$env$name?void 0:null===(_process$env$name$toL=_process$env$name.toLowerCase())||void 0===_process$env$name$toL?void 0:_process$env$name$toL.trim();if(null!=sanitizedValue&&""!==sanitizedValue){if(!["true","false"].includes(sanitizedValue))throw err_1(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);set("true"===sanitizedValue)}}function readProcessEnvStringArrayFlag(name,set){var _process$env$name2;let sanitizedValue=null===(_process$env$name2=process.env[name])||void 0===_process$env$name2?void 0:_process$env$name2.trim();null!=sanitizedValue&&""!==sanitizedValue&&set(sanitizedValue.split(/\s*,\s*|\s+/))}function Recoil_gkx_OSS(gk){return env.RECOIL_GKS_ENABLED.has(gk)}void 0!==process&&(null==process?void 0:process.env)!=null&&(readProcessEnvBooleanFlag("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",value=>{env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=value}),readProcessEnvStringArrayFlag("RECOIL_GKS_ENABLED",value=>{value.forEach(gk=>{env.RECOIL_GKS_ENABLED.add(gk)})})),Recoil_gkx_OSS.setPass=gk=>{env.RECOIL_GKS_ENABLED.add(gk)},Recoil_gkx_OSS.setFail=gk=>{env.RECOIL_GKS_ENABLED.delete(gk)},Recoil_gkx_OSS.clear=()=>{env.RECOIL_GKS_ENABLED.clear()};var Recoil_gkx=Recoil_gkx_OSS,recoverableViolation_1=function recoverableViolation(message,_projectName,{error}={}){return null};let createMutableSource=null!==(_createMutableSource=react__WEBPACK_IMPORTED_MODULE_0__.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react__WEBPACK_IMPORTED_MODULE_0__.unstable_createMutableSource,useMutableSource=null!==(_useMutableSource=react__WEBPACK_IMPORTED_MODULE_0__.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react__WEBPACK_IMPORTED_MODULE_0__.unstable_useMutableSource,useSyncExternalStore=null!==(_useSyncExternalStore=react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)&&void 0!==_useSyncExternalStore?_useSyncExternalStore:react__WEBPACK_IMPORTED_MODULE_0__.unstable_useSyncExternalStore,ReactRendererVersionMismatchWarnOnce=!1;function currentRendererSupportsUseSyncExternalStore(){var _ReactCurrentDispatch;let{ReactCurrentDispatcher,ReactCurrentOwner}=react__WEBPACK_IMPORTED_MODULE_0__.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,isUseSyncExternalStoreSupported=null!=(null!==(_ReactCurrentDispatch=null==ReactCurrentDispatcher?void 0:ReactCurrentDispatcher.current)&&void 0!==_ReactCurrentDispatch?_ReactCurrentDispatch:ReactCurrentOwner.currentDispatcher).useSyncExternalStore;return!useSyncExternalStore||isUseSyncExternalStoreSupported||ReactRendererVersionMismatchWarnOnce||(ReactRendererVersionMismatchWarnOnce=!0,recoverableViolation_1("A React renderer without React 18+ API support is being used with React 18+.")),isUseSyncExternalStoreSupported}function reactMode(){return Recoil_gkx("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:Recoil_gkx("recoil_sync_external_store")&&null!=useSyncExternalStore?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:Recoil_gkx("recoil_mutable_source")&&null!=useMutableSource&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?Recoil_gkx("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:Recoil_gkx("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var Recoil_ReactMode={createMutableSource,useMutableSource,useSyncExternalStore,currentRendererSupportsUseSyncExternalStore,reactMode,isFastRefreshEnabled:function isFastRefreshEnabled(){return!1}};class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}toJSON(){return{key:this.key}}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}function isRecoilValue(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}var Recoil_RecoilValue={AbstractRecoilValue,RecoilState,RecoilValueReadOnly,isRecoilValue},Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue.AbstractRecoilValue,RecoilState:Recoil_RecoilValue.RecoilState,RecoilValueReadOnly:Recoil_RecoilValue.RecoilValueReadOnly,isRecoilValue:Recoil_RecoilValue.isRecoilValue}),expectationViolation_1=function expectationViolation(format,...args){},Recoil_mapIterable=function mapIterable(iterable,callback){return function*(){let index=0;for(let value of iterable)yield callback(value,index++)}()};let{isFastRefreshEnabled:isFastRefreshEnabled$1}=Recoil_ReactMode;class DefaultValue{}let DEFAULT_VALUE=new DefaultValue,nodes=new Map,recoilValues=new Map;function recoilValuesForKeys(keys){return Recoil_mapIterable(keys,key=>Recoil_nullthrows(recoilValues.get(key)))}function checkForDuplicateAtomKey(key){nodes.has(key)&&console.warn(`Duplicate atom key "${key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`)}function registerNode(node){env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&checkForDuplicateAtomKey(node.key),nodes.set(node.key,node);let recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue}class NodeMissingError extends Error{}function getNode(key){let node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node}function getNodeMaybe(key){return nodes.get(key)}let configDeletionHandlers=new Map;function deleteNodeConfigIfPossible(key){var _node$shouldDeleteCon,_getConfigDeletionHan;if(!Recoil_gkx("recoil_memory_managament_2020"))return;let node=nodes.get(key);null!=node&&null!==(_node$shouldDeleteCon=node.shouldDeleteConfigOnRelease)&&void 0!==_node$shouldDeleteCon&&_node$shouldDeleteCon.call(node)&&(nodes.delete(key),null===(_getConfigDeletionHan=getConfigDeletionHandler(key))||void 0===_getConfigDeletionHan||_getConfigDeletionHan(),configDeletionHandlers.delete(key))}function getConfigDeletionHandler(key){return configDeletionHandlers.get(key)}var Recoil_Node={nodes,recoilValues,registerNode,getNode,getNodeMaybe,deleteNodeConfigIfPossible,setConfigDeletionHandler:function setConfigDeletionHandler(key,fn){Recoil_gkx("recoil_memory_managament_2020")&&(void 0===fn?configDeletionHandlers.delete(key):configDeletionHandlers.set(key,fn))},getConfigDeletionHandler,recoilValuesForKeys,NodeMissingError,DefaultValue,DEFAULT_VALUE},Recoil_Queue={enqueueExecution:function enqueueExecution(s,f){f()}},hamt_1=function createCommonjsModule(fn,module){return fn(module={exports:{}},module.exports),module.exports}(function(module){var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},hamt={},nothing={},constant=function constant(x){return function(){return x}},hash=hamt.hash=function(str){var type=void 0===str?"undefined":_typeof(str);if("number"===type)return str;"string"!==type&&(str+="");for(var hash=0,i=0,len=str.length;i<len;++i)hash=(hash<<5)-hash+str.charCodeAt(i)|0;return hash},hashFragment=function hashFragment(shift,h){return h>>>shift&31},toBitmap=function toBitmap(x){return 1<<x},fromBitmap=function fromBitmap(bitmap,bit){var x;return x=bitmap&bit-1,x-=x>>1&1431655765,x=(x=(858993459&x)+(x>>2&858993459))+(x>>4)&252645135,x+=x>>8,127&(x+=x>>16)},arrayUpdate=function arrayUpdate(mutate,at,v,arr){var out=arr;if(!mutate){var len=arr.length;out=Array(len);for(var i=0;i<len;++i)out[i]=arr[i]}return out[at]=v,out},arraySpliceOut=function arraySpliceOut(mutate,at,arr){var newLen=arr.length-1,i=0,g=0,out=arr;if(mutate)i=g=at;else for(out=Array(newLen);i<at;)out[g++]=arr[i++];for(++i;i<=newLen;)out[g++]=arr[i++];return mutate&&(out.length=newLen),out},arraySpliceIn=function arraySpliceIn(mutate,at,v,arr){var len=arr.length;if(mutate){for(var _i=len;_i>=at;)arr[_i--]=arr[_i];return arr[at]=v,arr}for(var i=0,g=0,out=Array(len+1);i<at;)out[g++]=arr[i++];for(out[at]=v;i<len;)out[++g]=arr[i++];return out},empty={__hamt_isEmpty:!0},isEmptyNode=function isEmptyNode(x){return x===empty||x&&x.__hamt_isEmpty},Leaf=function Leaf(edit,hash,key,value){return{type:1,edit:edit,hash:hash,key:key,value:value,_modify:Leaf__modify}},Collision=function Collision(edit,hash,children){return{type:2,edit:edit,hash:hash,children:children,_modify:Collision__modify}},IndexedNode=function IndexedNode(edit,mask,children){return{type:3,edit:edit,mask:mask,children:children,_modify:IndexedNode__modify}},ArrayNode=function ArrayNode(edit,size,children){return{type:4,edit:edit,size:size,children:children,_modify:ArrayNode__modify}},expand=function expand(edit,frag,child,bitmap,subNodes){for(var arr=[],bit=bitmap,count=0,i=0;bit;++i)1&bit&&(arr[i]=subNodes[count++]),bit>>>=1;return arr[frag]=child,ArrayNode(edit,count+1,arr)},pack=function pack(edit,count,removed,elements){for(var children=Array(count-1),g=0,bitmap=0,i=0,len=elements.length;i<len;++i)if(i!==removed){var elem=elements[i];elem&&!isEmptyNode(elem)&&(children[g++]=elem,bitmap|=1<<i)}return IndexedNode(edit,bitmap,children)},mergeLeaves=function mergeLeaves(edit,shift,h1,n1,h2,n2){if(h1===h2)return Collision(edit,h1,[n2,n1]);var subH1=hashFragment(shift,h1),subH2=hashFragment(shift,h2);return IndexedNode(edit,toBitmap(subH1)|toBitmap(subH2),subH1===subH2?[mergeLeaves(edit,shift+5,h1,n1,h2,n2)]:subH1<subH2?[n1,n2]:[n2,n1])},updateCollisionList=function updateCollisionList(mutate,edit,keyEq,h,list,f,k,size){for(var len=list.length,i=0;i<len;++i){var child=list[i];if(keyEq(k,child.key)){var value=child.value,_newValue=f(value);if(_newValue===value)return list;if(_newValue===nothing)return--size.value,arraySpliceOut(mutate,i,list);return arrayUpdate(mutate,i,Leaf(edit,h,k,_newValue),list)}}var newValue=f();return newValue===nothing?list:(++size.value,arrayUpdate(mutate,len,Leaf(edit,h,k,newValue),list))},canEditNode=function canEditNode(edit,node){return edit===node.edit},Leaf__modify=function Leaf__modify(edit,keyEq,shift,f,h,k,size){if(keyEq(k,this.key)){var _v=f(this.value);return _v===this.value?this:_v===nothing?(--size.value,empty):canEditNode(edit,this)?(this.value=_v,this):Leaf(edit,h,k,_v)}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},Collision__modify=function Collision__modify(edit,keyEq,shift,f,h,k,size){if(h===this.hash){var list=updateCollisionList(canEditNode(edit,this),edit,keyEq,this.hash,this.children,f,k,size);return list===this.children?this:list.length>1?Collision(edit,this.hash,list):list[0]}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},IndexedNode__modify=function IndexedNode__modify(edit,keyEq,shift,f,h,k,size){var node,mask=this.mask,children=this.children,frag=hashFragment(shift,h),bit=toBitmap(frag),indx=fromBitmap(mask,bit),exists=mask&bit,current=exists?children[indx]:empty,child=current._modify(edit,keyEq,shift+5,f,h,k,size);if(current===child)return this;var canEdit=canEditNode(edit,this),bitmap=mask,newChildren=void 0;if(exists&&isEmptyNode(child)){if(!(bitmap&=~bit))return empty;if(children.length<=2&&((node=children[1^indx])===empty||1===node.type||2===node.type))return children[1^indx];newChildren=arraySpliceOut(canEdit,indx,children)}else if(exists||isEmptyNode(child))newChildren=arrayUpdate(canEdit,indx,child,children);else{if(children.length>=16)return expand(edit,frag,child,mask,children);bitmap|=bit,newChildren=arraySpliceIn(canEdit,indx,child,children)}return canEdit?(this.mask=bitmap,this.children=newChildren,this):IndexedNode(edit,bitmap,newChildren)},ArrayNode__modify=function ArrayNode__modify(edit,keyEq,shift,f,h,k,size){var count=this.size,children=this.children,frag=hashFragment(shift,h),child=children[frag],newChild=(child||empty)._modify(edit,keyEq,shift+5,f,h,k,size);if(child===newChild)return this;var canEdit=canEditNode(edit,this),newChildren=void 0;if(isEmptyNode(child)&&!isEmptyNode(newChild))++count,newChildren=arrayUpdate(canEdit,frag,newChild,children);else if(!isEmptyNode(child)&&isEmptyNode(newChild)){if(--count<=8)return pack(edit,count,frag,children);newChildren=arrayUpdate(canEdit,frag,empty,children)}else newChildren=arrayUpdate(canEdit,frag,newChild,children);return canEdit?(this.size=count,this.children=newChildren,this):ArrayNode(edit,count,newChildren)};function Map1(editable,edit,config,root,size){this._editable=editable,this._edit=edit,this._config=config,this._root=root,this._size=size}empty._modify=function(edit,keyEq,shift,f,h,k,size){var v=f();return v===nothing?empty:(++size.value,Leaf(edit,h,k,v))},Map1.prototype.setTree=function(newRoot,newSize){return this._editable?(this._root=newRoot,this._size=newSize,this):newRoot===this._root?this:new Map1(this._editable,this._edit,this._config,newRoot,newSize)};var tryGetHash=hamt.tryGetHash=function(alt,hash,key,map){for(var node=map._root,shift=0,keyEq=map._config.keyEq;;)switch(node.type){case 1:return keyEq(key,node.key)?node.value:alt;case 2:if(hash===node.hash)for(var children=node.children,i=0,len=children.length;i<len;++i){var child=children[i];if(keyEq(key,child.key))return child.value}return alt;case 3:var bit=toBitmap(hashFragment(shift,hash));if(node.mask&bit){node=node.children[fromBitmap(node.mask,bit)],shift+=5;break}return alt;case 4:if(node=node.children[hashFragment(shift,hash)]){shift+=5;break}return alt;default:return alt}};Map1.prototype.tryGetHash=function(alt,hash,key){return tryGetHash(alt,hash,key,this)};var tryGet=hamt.tryGet=function(alt,key,map){return tryGetHash(alt,map._config.hash(key),key,map)};Map1.prototype.tryGet=function(alt,key){return tryGet(alt,key,this)};var getHash=hamt.getHash=function(hash,key,map){return tryGetHash(void 0,hash,key,map)};Map1.prototype.getHash=function(hash,key){return getHash(hash,key,this)},hamt.get=function(key,map){return tryGetHash(void 0,map._config.hash(key),key,map)},Map1.prototype.get=function(key,alt){return tryGet(alt,key,this)};var hasHash=hamt.has=function(hash,key,map){return tryGetHash(nothing,hash,key,map)!==nothing};Map1.prototype.hasHash=function(hash,key){return hasHash(hash,key,this)};var has=hamt.has=function(key,map){return hasHash(map._config.hash(key),key,map)};Map1.prototype.has=function(key){return has(key,this)};var defKeyCompare=function defKeyCompare(x,y){return x===y};hamt.make=function(config){return new Map1(0,0,{keyEq:config&&config.keyEq||defKeyCompare,hash:config&&config.hash||hash},empty,0)},hamt.empty=hamt.make();var isEmpty=hamt.isEmpty=function(map){return map&&!!isEmptyNode(map._root)};Map1.prototype.isEmpty=function(){return isEmpty(this)};var modifyHash=hamt.modifyHash=function(f,hash,key,map){var size={value:map._size},newRoot=map._root._modify(map._editable?map._edit:NaN,map._config.keyEq,0,f,hash,key,size);return map.setTree(newRoot,size.value)};Map1.prototype.modifyHash=function(hash,key,f){return modifyHash(f,hash,key,this)};var modify=hamt.modify=function(f,key,map){return modifyHash(f,map._config.hash(key),key,map)};Map1.prototype.modify=function(key,f){return modify(f,key,this)};var setHash=hamt.setHash=function(hash,key,value,map){return modifyHash(constant(value),hash,key,map)};Map1.prototype.setHash=function(hash,key,value){return setHash(hash,key,value,this)};var set=hamt.set=function(key,value,map){return setHash(map._config.hash(key),key,value,map)};Map1.prototype.set=function(key,value){return set(key,value,this)};var del=constant(nothing),removeHash=hamt.removeHash=function(hash,key,map){return modifyHash(del,hash,key,map)};Map1.prototype.removeHash=Map1.prototype.deleteHash=function(hash,key){return removeHash(hash,key,this)};var remove=hamt.remove=function(key,map){return removeHash(map._config.hash(key),key,map)};Map1.prototype.remove=Map1.prototype.delete=function(key){return remove(key,this)};var beginMutation=hamt.beginMutation=function(map){return new Map1(map._editable+1,map._edit+1,map._config,map._root,map._size)};Map1.prototype.beginMutation=function(){return beginMutation(this)};var endMutation=hamt.endMutation=function(map){return map._editable=map._editable&&map._editable-1,map};Map1.prototype.endMutation=function(){return endMutation(this)};var mutate=hamt.mutate=function(f,map){var transient=beginMutation(map);return f(transient),endMutation(transient)};Map1.prototype.mutate=function(f){return mutate(f,this)};var appk=function appk(k){return k&&lazyVisitChildren(k[0],k[1],k[2],k[3],k[4])},lazyVisitChildren=function lazyVisitChildren(len,children,i,f,k){for(;i<len;){var child=children[i++];if(child&&!isEmptyNode(child))return lazyVisit(child,f,[len,children,i,f,k])}return appk(k)},lazyVisit=function lazyVisit(node,f,k){switch(node.type){case 1:return{value:f(node),rest:k};case 2:case 4:case 3:var children=node.children;return lazyVisitChildren(children.length,children,0,f,k);default:return appk(k)}},DONE={done:!0};function MapIterator(v){this.v=v}MapIterator.prototype.next=function(){if(!this.v)return DONE;var v0=this.v;return this.v=appk(v0.rest),v0},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function visit(map,f){return new MapIterator(lazyVisit(map._root,f))},buildPairs=function buildPairs(x){return[x.key,x.value]},entries=hamt.entries=function(map){return visit(map,buildPairs)};Map1.prototype.entries=Map1.prototype[Symbol.iterator]=function(){return entries(this)};var buildKeys=function buildKeys(x){return x.key},keys=hamt.keys=function(map){return visit(map,buildKeys)};Map1.prototype.keys=function(){return keys(this)};var buildValues=function buildValues(x){return x.value},values=hamt.values=Map1.prototype.values=function(map){return visit(map,buildValues)};Map1.prototype.values=function(){return values(this)};var fold=hamt.fold=function(f,z,m){var root=m._root;if(1===root.type)return f(z,root.value,root.key);for(var toVisit=[root.children],children=void 0;children=toVisit.pop();)for(var i=0,len=children.length;i<len;){var child=children[i++];child&&child.type&&(1===child.type?z=f(z,child.value,child.key):toVisit.push(child.children))}return z};Map1.prototype.fold=function(f,z){return fold(f,z,this)};var forEach=hamt.forEach=function(f,map){return fold(function(_,value,key){return f(value,key,map)},null,map)};Map1.prototype.forEach=function(f){return forEach(f,this)};var count=hamt.count=function(map){return map._size};Map1.prototype.count=function(){return count(this)},Object.defineProperty(Map1.prototype,"size",{get:Map1.prototype.count}),module.exports?module.exports=hamt:undefined.hamt=hamt});class BuiltInMap{constructor(existing){_defineProperty(this,"_map",void 0),this._map=new Map(null==existing?void 0:existing.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(k){return this._map.get(k)}has(k){return this._map.has(k)}set(k,v){return this._map.set(k,v),this}delete(k){return this._map.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}}class HashArrayMappedTrieMap{constructor(existing){if(_defineProperty(this,"_hamt",hamt_1.empty.beginMutation()),existing instanceof HashArrayMappedTrieMap){let h=existing._hamt.endMutation();existing._hamt=h.beginMutation(),this._hamt=h.beginMutation()}else if(existing)for(let[k,v]of existing.entries())this._hamt.set(k,v)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(k){return this._hamt.get(k)}has(k){return this._hamt.has(k)}set(k,v){return this._hamt.set(k,v),this}delete(k){return this._hamt.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}}function persistentMap(existing){return Recoil_gkx("recoil_hamt_2020")?new HashArrayMappedTrieMap(existing):new BuiltInMap(existing)}var Recoil_PersistentMap$1=Object.freeze({__proto__:null,persistentMap:{persistentMap}.persistentMap}),Recoil_differenceSets=function differenceSets(set,...setsWithValuesToRemove){let ret=new Set;FIRST:for(let value of set){for(let otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret},Recoil_mapMap=function mapMap(map,callback){let result=new Map;return map.forEach((value,key)=>{result.set(key,callback(value,key))}),result};function mergeDepsIntoGraph(key,newDeps,graph,olderGraph){let{nodeDeps,nodeToNodeSubscriptions}=graph,oldDeps=nodeDeps.get(key);if(!oldDeps||!olderGraph||oldDeps===olderGraph.nodeDeps.get(key)){for(let dep of(nodeDeps.set(key,newDeps),null==oldDeps?newDeps:Recoil_differenceSets(newDeps,oldDeps)))nodeToNodeSubscriptions.has(dep)||nodeToNodeSubscriptions.set(dep,new Set),Recoil_nullthrows(nodeToNodeSubscriptions.get(dep)).add(key);if(oldDeps)for(let dep of Recoil_differenceSets(oldDeps,newDeps)){if(!nodeToNodeSubscriptions.has(dep))return;let existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));existing.delete(key),0===existing.size&&nodeToNodeSubscriptions.delete(dep)}}}var Recoil_Graph={cloneGraph:function cloneGraph(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,s=>new Set(s)),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,s=>new Set(s))}},graph:function makeGraph(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function saveDepsToStore(key,deps,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3,_storeState$nextTree2;let storeState=store.getState();version===storeState.currentTree.version||version===(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)||version===(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT?void 0:_storeState$previousT.version)||recoverableViolation_1("Tried to save dependencies to a discarded tree");let graph=store.getGraph(version);if(mergeDepsIntoGraph(key,deps,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)&&mergeDepsIntoGraph(key,deps,store.getGraph(storeState.currentTree.version),graph),version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){let nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;void 0!==nextVersion&&mergeDepsIntoGraph(key,deps,store.getGraph(nextVersion),graph)}}};let nextTreeStateVersion=0,nextStoreID=0,nextComponentID=0;var Recoil_Keys={getNextTreeStateVersion:()=>nextTreeStateVersion++,getNextStoreID:()=>nextStoreID++,getNextComponentID:()=>nextComponentID++};let{persistentMap:persistentMap$1}=Recoil_PersistentMap$1,{graph}=Recoil_Graph,{getNextTreeStateVersion:getNextTreeStateVersion$1}=Recoil_Keys;function makeEmptyTreeState(){let version=getNextTreeStateVersion$1();return{version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:persistentMap$1(),nonvalidatedAtoms:persistentMap$1()}}function makeEmptyStoreState(){let currentTree=makeEmptyTreeState();return{currentTree,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(currentTree.version,graph()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Recoil_State={makeEmptyTreeState,makeEmptyStoreState,getNextTreeStateVersion:getNextTreeStateVersion$1};class RetentionZone{}function retentionZone(){return new RetentionZone}var Recoil_RetentionZone={RetentionZone,retentionZone},Recoil_CopyOnWrite={setByAddingToSet:function setByAddingToSet(set,v){let next=new Set(set);return next.add(v),next},setByDeletingFromSet:function setByDeletingFromSet(set,v){let next=new Set(set);return next.delete(v),next},mapBySettingInMap:function mapBySettingInMap(map,k,v){let next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function mapByUpdatingInMap(map,k,updater){let next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function mapByDeletingFromMap(map,k){let next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function mapByDeletingMultipleFromMap(map,ks){let next=new Map(map);return ks.forEach(k=>next.delete(k)),next}},Recoil_filterIterable=function* filterIterable(iterable,predicate){let index=0;for(let value of iterable)predicate(value,index++)&&(yield value)},Recoil_lazyProxy=function lazyProxy(base,factories){return new Proxy(base,{get:(target,prop)=>(!(prop in target)&&prop in factories&&(target[prop]=factories[prop]()),target[prop]),ownKeys:target=>Object.keys(target)})};let{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1,recoilValuesForKeys:recoilValuesForKeys$1}=Recoil_Node,{RetentionZone:RetentionZone$1}=Recoil_RetentionZone,{setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}function initializeRetentionForNode(store,nodeKey,retainedBy){if(!Recoil_gkx("recoil_memory_managament_2020"))return()=>void 0;let{nodesRetainedByZone}=store.getState().retention;function addToZone(zone){let set=nodesRetainedByZone.get(zone);set||nodesRetainedByZone.set(zone,set=new Set),set.add(nodeKey)}if(retainedBy instanceof RetentionZone$1)addToZone(retainedBy);else if(Array.isArray(retainedBy))for(let zone of retainedBy)addToZone(zone);return()=>{if(!Recoil_gkx("recoil_memory_managament_2020"))return;let{retention}=store.getState();function deleteFromZone(zone){let set=retention.nodesRetainedByZone.get(zone);null==set||set.delete(nodeKey),set&&0===set.size&&retention.nodesRetainedByZone.delete(zone)}if(retainedBy instanceof RetentionZone$1)deleteFromZone(retainedBy);else if(Array.isArray(retainedBy))for(let zone of retainedBy)deleteFromZone(zone)}}function initializeNodeIfNewToStore(store,treeState,key,trigger){let storeState=store.getState();if(storeState.nodeCleanupFunctions.has(key))return;let node=getNode$1(key),retentionCleanup=initializeRetentionForNode(store,key,node.retainedBy),nodeCleanup=node.init(store,treeState,trigger);storeState.nodeCleanupFunctions.set(key,()=>{nodeCleanup(),retentionCleanup()})}function peekNodeLoadable(store,state,key){return getNode$1(key).peek(store,state)}function peekNodeInfo(store,state,key){let storeState=store.getState(),graph=store.getGraph(state.version),type=getNode$1(key).nodeType;return Recoil_lazyProxy({type},{loadable:()=>peekNodeLoadable(store,state,key),isActive:()=>storeState.knownAtoms.has(key)||storeState.knownSelectors.has(key),isSet:()=>"selector"!==type&&state.atomValues.has(key),isModified:()=>state.dirtyAtoms.has(key),deps:()=>{var _graph$nodeDeps$get;return recoilValuesForKeys$1(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[])},subscribers:()=>{var _storeState$nodeToCom,_storeState$nodeToCom2;return{nodes:recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store,state,new Set([key])),nodeKey=>nodeKey!==key)),components:Recoil_mapIterable(null!==(_storeState$nodeToCom=null===(_storeState$nodeToCom2=storeState.nodeToComponentSubscriptions.get(key))||void 0===_storeState$nodeToCom2?void 0:_storeState$nodeToCom2.values())&&void 0!==_storeState$nodeToCom?_storeState$nodeToCom:[],([name])=>({name}))}}})}function getDownstreamNodes(store,state,keys){let visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;for(let downstreamNode of(visitedNodes.add(key),null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet))visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}var Recoil_FunctionalCore={getNodeLoadable:function getNodeLoadable(store,state,key){return initializeNodeIfNewToStore(store,state,key,"get"),getNode$1(key).get(store,state)},peekNodeLoadable,setNodeValue:function setNodeValue(store,state,key,newValue){let node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);let set=node.set;return initializeNodeIfNewToStore(store,state,key,"set"),set(store,state,newValue)},initializeNode:function initializeNode(store,key,trigger){initializeNodeIfNewToStore(store,store.getState().currentTree,key,trigger)},cleanUpNode:function cleanUpNode(store,key){var _state$nodeCleanupFun;let state=store.getState();null===(_state$nodeCleanupFun=state.nodeCleanupFunctions.get(key))||void 0===_state$nodeCleanupFun||_state$nodeCleanupFun(),state.nodeCleanupFunctions.delete(key)},setUnvalidatedAtomValue_DEPRECATED:function setUnvalidatedAtomValue_DEPRECATED(state,key,newValue){var _node$invalidate;let node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),{...state,atomValues:state.atomValues.clone().delete(key),nonvalidatedAtoms:state.nonvalidatedAtoms.clone().set(key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},peekNodeInfo,getDownstreamNodes};let _invalidateMemoizedSnapshot=null;var Recoil_SnapshotCache={setInvalidateMemoizedSnapshot:function setInvalidateMemoizedSnapshot(invalidate){_invalidateMemoizedSnapshot=invalidate},invalidateMemoizedSnapshot:function invalidateMemoizedSnapshot(){var _invalidateMemoizedSn;null===(_invalidateMemoizedSn=_invalidateMemoizedSnapshot)||void 0===_invalidateMemoizedSn||_invalidateMemoizedSn()}};let{getDownstreamNodes:getDownstreamNodes$1,getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1}=Recoil_FunctionalCore,{getNextComponentID:getNextComponentID$1}=Recoil_Keys,{getNode:getNode$2,getNodeMaybe:getNodeMaybe$2}=Recoil_Node,{DefaultValue:DefaultValue$1}=Recoil_Node,{reactMode:reactMode$1}=Recoil_ReactMode,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1,{invalidateMemoizedSnapshot:invalidateMemoizedSnapshot$1}=Recoil_SnapshotCache;function valueFromValueOrUpdater(store,state,{key},valueOrUpdater){if("function"!=typeof valueOrUpdater)return valueOrUpdater;{let current=getNodeLoadable$1(store,state,key);if("loading"===current.state){let msg=`Tried to set atom or selector "${key}" using an updater function while the current state is pending, this is not currently supported.`;throw recoverableViolation_1(msg),err_1(msg)}if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}}function applyAction(store,state,action){if("set"===action.type){let{recoilValue,valueOrUpdater}=action,newValue=valueFromValueOrUpdater(store,state,recoilValue,valueOrUpdater);for(let[key,loadable]of setNodeValue$1(store,state,recoilValue.key,newValue).entries())writeLoadableToTreeState(state,key,loadable)}else if("setLoadable"===action.type){let{recoilValue:{key},loadable}=action;writeLoadableToTreeState(state,key,loadable)}else if("markModified"===action.type){let{recoilValue:{key}}=action;state.dirtyAtoms.add(key)}else if("setUnvalidated"===action.type){var _node$invalidate;let{recoilValue:{key},unvalidatedValue}=action,node=getNodeMaybe$2(key);null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),state.atomValues.delete(key),state.nonvalidatedAtoms.set(key,unvalidatedValue),state.dirtyAtoms.add(key)}else recoverableViolation_1(`Unknown action ${action.type}`)}function writeLoadableToTreeState(state,key,loadable){"hasValue"===loadable.state&&loadable.contents instanceof DefaultValue$1?state.atomValues.delete(key):state.atomValues.set(key,loadable),state.dirtyAtoms.add(key),state.nonvalidatedAtoms.delete(key)}function applyActionsToStore(store,actions){store.replaceState(state=>{let newState=copyTreeState(state);for(let action of actions)applyAction(store,newState,action);return invalidateDownstreams(store,newState),invalidateMemoizedSnapshot$1(),newState})}function queueOrPerformStateUpdate(store,action){if(batchStack.length){let actionsByStore=batchStack[batchStack.length-1],actions=actionsByStore.get(store);actions||actionsByStore.set(store,actions=[]),actions.push(action)}else applyActionsToStore(store,[action])}let batchStack=[];function copyTreeState(state){return{...state,atomValues:state.atomValues.clone(),nonvalidatedAtoms:state.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(state.dirtyAtoms)}}function invalidateDownstreams(store,state){for(let key of getDownstreamNodes$1(store,state,state.dirtyAtoms)){var _getNodeMaybe,_getNodeMaybe$invalid;null===(_getNodeMaybe=getNodeMaybe$2(key))||void 0===_getNodeMaybe||null===(_getNodeMaybe$invalid=_getNodeMaybe.invalidate)||void 0===_getNodeMaybe$invalid||_getNodeMaybe$invalid.call(_getNodeMaybe,state)}}function setRecoilValue(store,recoilValue,valueOrUpdater){queueOrPerformStateUpdate(store,{type:"set",recoilValue,valueOrUpdater})}function setRecoilValueLoadable(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);queueOrPerformStateUpdate(store,{type:"setLoadable",recoilValue,loadable:loadable})}var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function getRecoilValueAsLoadable(store,{key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;let storeState=store.getState();treeState.version===storeState.currentTree.version||treeState.version===(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)||treeState.version===(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT?void 0:_storeState$previousT.version)||recoverableViolation_1("Tried to read from a discarded tree");let loadable=getNodeLoadable$1(store,treeState,key);return"loading"===loadable.state&&loadable.contents.catch(()=>{}),loadable},setRecoilValue,setRecoilValueLoadable,markRecoilValueModified:function markRecoilValueModified(store,recoilValue){queueOrPerformStateUpdate(store,{type:"markModified",recoilValue})},setUnvalidatedRecoilValue:function setUnvalidatedRecoilValue(store,recoilValue,unvalidatedValue){queueOrPerformStateUpdate(store,{type:"setUnvalidated",recoilValue,unvalidatedValue})},subscribeToRecoilValue:function subscribeToRecoilValue(store,{key},callback,componentDebugName=null){let subID=getNextComponentID$1(),storeState=store.getState();storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]);let mode=reactMode$1();if(mode.early&&("LEGACY"===mode.mode||"MUTABLE_SOURCE"===mode.mode)){let nextTree=store.getState().nextTree;nextTree&&nextTree.dirtyAtoms.has(key)&&callback(nextTree)}return{release:()=>{let releaseStoreState=store.getState(),subs=releaseStoreState.nodeToComponentSubscriptions.get(key);if(void 0===subs||!subs.has(subID)){recoverableViolation_1(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);return}subs.delete(subID),0===subs.size&&releaseStoreState.nodeToComponentSubscriptions.delete(key)}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:function applyAtomValueWrites(atomValues,writes){let result=atomValues.clone();return writes.forEach((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)}),result},batchStart:function batchStart(){let actionsByStore=new Map;return batchStack.push(actionsByStore),()=>{for(let[store,actions]of actionsByStore)applyActionsToStore(store,actions);batchStack.pop()!==actionsByStore&&recoverableViolation_1("Incorrect order of batch popping")}},writeLoadableToTreeState,invalidateDownstreams,copyTreeState,refreshRecoilValue:function refreshRecoilValue(store,recoilValue){var _node$clearCache;let{currentTree}=store.getState(),node=getNode$2(recoilValue.key);null===(_node$clearCache=node.clearCache)||void 0===_node$clearCache||_node$clearCache.call(node,store,currentTree)}},Recoil_someSet=function someSet(set,callback,context){let iterator=set.entries(),current=iterator.next();for(;!current.done;){let entry=current.value;if(callback.call(context,entry[1],entry[0],set))return!0;current=iterator.next()}return!1};let{cleanUpNode:cleanUpNode$1}=Recoil_FunctionalCore,{deleteNodeConfigIfPossible:deleteNodeConfigIfPossible$1,getNode:getNode$3}=Recoil_Node,{RetentionZone:RetentionZone$2}=Recoil_RetentionZone,emptySet$1=new Set;function releaseRetainablesNowOnCurrentTree(store,retainables){let storeState=store.getState(),treeState=storeState.currentTree;if(storeState.nextTree){recoverableViolation_1("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let nodes=new Set;for(let r of retainables)if(r instanceof RetentionZone$2)for(let n of nodesRetainedByZone(storeState,r))nodes.add(n);else nodes.add(r);for(let node of findReleasableNodes(store,nodes))releaseNode(store,treeState,node)}function findReleasableNodes(store,searchFromNodes){let storeState=store.getState(),treeState=storeState.currentTree,graph=store.getGraph(treeState.version),releasableNodes=new Set,nonReleasableNodes=new Set;return findReleasableNodesInner(searchFromNodes),releasableNodes;function findReleasableNodesInner(searchFromNodes){var _storeState$retention,_graph$nodeDeps$get;let releasableNodesFoundThisIteration=new Set;for(let node of getDownstreamNodesInTopologicalOrder(store,treeState,searchFromNodes,releasableNodes,nonReleasableNodes)){if("recoilRoot"===getNode$3(node).retainedBy||(null!==(_storeState$retention=storeState.retention.referenceCounts.get(node))&&void 0!==_storeState$retention?_storeState$retention:0)>0||zonesThatCouldRetainNode(node).some(z=>storeState.retention.referenceCounts.get(z))){nonReleasableNodes.add(node);continue}let nodeChildren=graph.nodeToNodeSubscriptions.get(node);if(nodeChildren&&Recoil_someSet(nodeChildren,child=>nonReleasableNodes.has(child))){nonReleasableNodes.add(node);continue}releasableNodes.add(node),releasableNodesFoundThisIteration.add(node)}let parents=new Set;for(let node of releasableNodesFoundThisIteration)for(let parent of null!==(_graph$nodeDeps$get=graph.nodeDeps.get(node))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:emptySet$1)releasableNodes.has(parent)||parents.add(parent);parents.size&&findReleasableNodesInner(parents)}}function getDownstreamNodesInTopologicalOrder(store,treeState,nodes,doNotDescendInto1,doNotDescendInto2){let graph=store.getGraph(treeState.version),answer=[],visited=new Set;for(;nodes.size>0;)visit(Recoil_nullthrows(nodes.values().next().value));return answer;function visit(node){if(doNotDescendInto1.has(node)||doNotDescendInto2.has(node)){nodes.delete(node);return}if(visited.has(node))return;let children=graph.nodeToNodeSubscriptions.get(node);if(children)for(let child of children)visit(child);visited.add(node),nodes.delete(node),answer.push(node)}}function releaseNode(store,treeState,node){var _storeState$retention2,_graph$nodeToNodeSubs;if(!Recoil_gkx("recoil_memory_managament_2020"))return;cleanUpNode$1(store,node);let storeState=store.getState();for(let zone of(storeState.knownAtoms.delete(node),storeState.knownSelectors.delete(node),storeState.nodeTransactionSubscriptions.delete(node),storeState.retention.referenceCounts.delete(node),zonesThatCouldRetainNode(node)))null===(_storeState$retention2=storeState.retention.nodesRetainedByZone.get(zone))||void 0===_storeState$retention2||_storeState$retention2.delete(node);treeState.atomValues.delete(node),treeState.dirtyAtoms.delete(node),treeState.nonvalidatedAtoms.delete(node);let graph=storeState.graphsByVersion.get(treeState.version);if(graph){let deps=graph.nodeDeps.get(node);if(void 0!==deps)for(let dep of(graph.nodeDeps.delete(node),deps))null===(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(dep))||void 0===_graph$nodeToNodeSubs||_graph$nodeToNodeSubs.delete(node);graph.nodeToNodeSubscriptions.delete(node)}deleteNodeConfigIfPossible$1(node)}function nodesRetainedByZone(storeState,zone){var _storeState$retention3;return null!==(_storeState$retention3=storeState.retention.nodesRetainedByZone.get(zone))&&void 0!==_storeState$retention3?_storeState$retention3:emptySet$1}function zonesThatCouldRetainNode(node){let retainedBy=getNode$3(node).retainedBy;return void 0===retainedBy||"components"===retainedBy||"recoilRoot"===retainedBy?[]:retainedBy instanceof RetentionZone$2?[retainedBy]:retainedBy}function scheduleOrPerformPossibleReleaseOfRetainable(store,retainable){let state=store.getState();state.nextTree?state.retention.retainablesToCheckForRelease.add(retainable):releaseRetainablesNowOnCurrentTree(store,new Set([retainable]))}function updateRetainCountToZero(store,retainable){Recoil_gkx("recoil_memory_managament_2020")&&(store.getState().retention.referenceCounts.delete(retainable),scheduleOrPerformPossibleReleaseOfRetainable(store,retainable))}var Recoil_Retention={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function updateRetainCount(store,retainable,delta){var _map$get;if(!Recoil_gkx("recoil_memory_managament_2020"))return;let map=store.getState().retention.referenceCounts,newCount=(null!==(_map$get=map.get(retainable))&&void 0!==_map$get?_map$get:0)+delta;0===newCount?updateRetainCountToZero(store,retainable):map.set(retainable,newCount)},updateRetainCountToZero,releaseScheduledRetainablesNow:function releaseScheduledRetainablesNow(store){if(!Recoil_gkx("recoil_memory_managament_2020"))return;let state=store.getState();releaseRetainablesNowOnCurrentTree(store,state.retention.retainablesToCheckForRelease),state.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function retainedByOptionWithDefault(r){return void 0===r?"recoilRoot":r}};let{unstable_batchedUpdates}=react_dom__WEBPACK_IMPORTED_MODULE_1__,{unstable_batchedUpdates:unstable_batchedUpdates$1}={unstable_batchedUpdates},{batchStart:batchStart$1}=Recoil_RecoilValueInterface,{unstable_batchedUpdates:unstable_batchedUpdates$2}={unstable_batchedUpdates:unstable_batchedUpdates$1},batcher=unstable_batchedUpdates$2||(batchFn=>batchFn());var Recoil_Batching={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>{batcher(()=>{let batchEnd=()=>void 0;try{batchEnd=batchStart$1(),callback()}finally{batchEnd()}})}},Recoil_concatIterables=function* concatIterables(iters){for(let iter of iters)for(let val of iter)yield val};let isSSR="undefined"==typeof Window||"undefined"==typeof window;var Recoil_Environment={isSSR,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product,isWindow:value=>!isSSR&&(value===window||value instanceof Window)};let{batchUpdates:batchUpdates$1}=Recoil_Batching,{initializeNode:initializeNode$1,peekNodeInfo:peekNodeInfo$1}=Recoil_FunctionalCore,{graph:graph$1}=Recoil_Graph,{getNextStoreID:getNextStoreID$1}=Recoil_Keys,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1,recoilValuesForKeys:recoilValuesForKeys$2}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1}=Recoil_RecoilValueInterface,{updateRetainCount:updateRetainCount$1}=Recoil_Retention,{setInvalidateMemoizedSnapshot:setInvalidateMemoizedSnapshot$1}=Recoil_SnapshotCache,{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State,{isSSR:isSSR$1}=Recoil_Environment,{memoizeOneWithArgsHashAndInvalidation:memoizeOneWithArgsHashAndInvalidation$1}={memoizeWithArgsHash:function memoizeWithArgsHash(fn,hashFunction){let cache;return(...args)=>{cache||(cache={});let key=hashFunction(...args);return Object.hasOwnProperty.call(cache,key)||(cache[key]=fn(...args)),cache[key]}},memoizeOneWithArgsHash:function memoizeOneWithArgsHash(fn,hashFunction){let lastKey,lastResult;return(...args)=>{let key=hashFunction(...args);return lastKey===key?lastResult:(lastKey=key,lastResult=fn(...args))}},memoizeOneWithArgsHashAndInvalidation:function memoizeOneWithArgsHashAndInvalidation(fn,hashFunction){let lastKey,lastResult;return[(...args)=>{let key=hashFunction(...args);return lastKey===key?lastResult:(lastKey=key,lastResult=fn(...args))},()=>{lastKey=null}]}};class Snapshot{constructor(storeState,parentStoreID){for(let nodeKey of(_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",1),_defineProperty(this,"getLoadable",recoilValue=>(this.checkRefCount_INTERNAL(),getRecoilValueAsLoadable$1(this._store,recoilValue))),_defineProperty(this,"getPromise",recoilValue=>(this.checkRefCount_INTERNAL(),this.getLoadable(recoilValue).toPromise())),_defineProperty(this,"getNodes_UNSTABLE",opt=>{if(this.checkRefCount_INTERNAL(),(null==opt?void 0:opt.isModified)===!0)return(null==opt?void 0:opt.isInitialized)===!1?[]:recoilValuesForKeys$2(this._store.getState().currentTree.dirtyAtoms);let knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return(null==opt?void 0:opt.isInitialized)==null?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms,knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),({key})=>!knownAtoms.has(key)&&!knownSelectors.has(key))}),_defineProperty(this,"getInfo_UNSTABLE",({key})=>(this.checkRefCount_INTERNAL(),peekNodeInfo$1(this._store,this._store.getState().currentTree,key))),_defineProperty(this,"map",mapper=>{this.checkRefCount_INTERNAL();let mutableSnapshot=new MutableSnapshot(this,batchUpdates$1);return mapper(mutableSnapshot),mutableSnapshot}),_defineProperty(this,"asyncMap",async mapper=>{this.checkRefCount_INTERNAL();let mutableSnapshot=new MutableSnapshot(this,batchUpdates$1);return mutableSnapshot.retain(),await mapper(mutableSnapshot),mutableSnapshot.autoRelease_INTERNAL(),mutableSnapshot}),this._store={storeID:getNextStoreID$1(),parentStoreID,getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{let graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));let newGraph=graph$1();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw err_1("Cannot subscribe to Snapshots")}},this._store.getState().knownAtoms))initializeNode$1(this._store,nodeKey,"get"),updateRetainCount$1(this._store,nodeKey,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&recoverableViolation_1("Attempt to retain() Snapshot that was already released."),this._refCount++;let released=!1;return()=>{released||(released=!0,this._release())}}autoRelease_INTERNAL(){isSSR$1||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach(cleanup=>cleanup()),this._store.getState().nodeCleanupFunctions.clear(),!Recoil_gkx("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){Recoil_gkx("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function cloneStoreState(store,treeState,bumpVersion=!1){let storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$2():treeState.version;return{currentTree:{version:bumpVersion?version:treeState.version,stateID:bumpVersion?version:treeState.stateID,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:treeState.atomValues.clone(),nonvalidatedAtoms:treeState.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(version,store.getGraph(treeState.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(),([key])=>[key,()=>{}]))}}function freshSnapshot(initializeState){let snapshot=new Snapshot(makeEmptyStoreState$1());return null!=initializeState?snapshot.map(initializeState):snapshot}let[memoizedCloneSnapshot,invalidateMemoizedSnapshot$2]=memoizeOneWithArgsHashAndInvalidation$1((store,version)=>{var _storeState$nextTree;let storeState=store.getState();return new Snapshot(cloneStoreState(store,"latest"===version?null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree:Recoil_nullthrows(storeState.previousTree)),store.storeID)},(store,version)=>{var _store$getState$nextT,_store$getState$previ;return String(version)+String(store.storeID)+String(null===(_store$getState$nextT=store.getState().nextTree)||void 0===_store$getState$nextT?void 0:_store$getState$nextT.version)+String(store.getState().currentTree.version)+String(null===(_store$getState$previ=store.getState().previousTree)||void 0===_store$getState$previ?void 0:_store$getState$previ.version)});function cloneSnapshot(store,version="latest"){let snapshot=memoizedCloneSnapshot(store,version);return snapshot.isRetained()?snapshot:(invalidateMemoizedSnapshot$2(),memoizedCloneSnapshot(store,version))}setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);class MutableSnapshot extends Snapshot{constructor(snapshot,batch){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0),snapshot.getStoreID()),_defineProperty(this,"_batch",void 0),_defineProperty(this,"set",(recoilState,newValueOrUpdater)=>{this.checkRefCount_INTERNAL();let store=this.getStore_INTERNAL();this._batch(()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,newValueOrUpdater)})}),_defineProperty(this,"reset",recoilState=>{this.checkRefCount_INTERNAL();let store=this.getStore_INTERNAL();this._batch(()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1)})}),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",values=>{this.checkRefCount_INTERNAL();let store=this.getStore_INTERNAL();batchUpdates$1(()=>{for(let[k,v]of values.entries())updateRetainCount$1(store,k,1),setUnvalidatedRecoilValue$1(store,new AbstractRecoilValue$2(k),v)})}),this._batch=batch}}var Recoil_Snapshot={Snapshot,MutableSnapshot,freshSnapshot,cloneSnapshot},Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot.Snapshot,MutableSnapshot:Recoil_Snapshot.MutableSnapshot,freshSnapshot:Recoil_Snapshot.freshSnapshot,cloneSnapshot:Recoil_Snapshot.cloneSnapshot}),Recoil_unionSets=function unionSets(...sets){let result=new Set;for(let set of sets)for(let value of set)result.add(value);return result};let{useRef}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRefInitOnce=function useRefInitOnce(initialValue){let ref=useRef(initialValue);return ref.current===initialValue&&"function"==typeof initialValue&&(ref.current=initialValue()),ref};let{getNextTreeStateVersion:getNextTreeStateVersion$3,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{cleanUpNode:cleanUpNode$2,getDownstreamNodes:getDownstreamNodes$2,initializeNode:initializeNode$2,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue_DEPRECATED:setUnvalidatedAtomValue_DEPRECATED$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{getNextStoreID:getNextStoreID$2}=Recoil_Keys,{createMutableSource:createMutableSource$1,reactMode:reactMode$2}=Recoil_ReactMode,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{releaseScheduledRetainablesNow:releaseScheduledRetainablesNow$1}=Recoil_Retention,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{useCallback,useContext,useEffect,useMemo,useRef:useRef$1,useState}=react__WEBPACK_IMPORTED_MODULE_0__;function notInAContext(){throw err_1("This component must be used inside a <RecoilRoot> component.")}let defaultStore=Object.freeze({storeID:getNextStoreID$2(),getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext}),stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(store){if(stateReplacerIsBeingExecuted)throw err_1("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let storeState=store.getState();if(null===storeState.nextTree){Recoil_gkx("recoil_memory_managament_2020")&&Recoil_gkx("recoil_release_on_cascading_update_killswitch_2021")&&storeState.commitDepth>0&&releaseScheduledRetainablesNow$1(store);let version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$3();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}let AppContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);function notifyComponents(store,storeState,treeState){for(let key of getDownstreamNodes$2(store,treeState,treeState.dirtyAtoms)){let comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(let[_subID,[_debugName,callback]]of comps)callback(treeState)}}function sendEndOfBatchNotifications(store){let storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(let[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(let[_,subscription]of subscriptions)subscription(store);for(let[_,subscription]of storeState.transactionSubscriptions)subscription(store);(!reactMode$2().early||storeState.suspendedComponentResolvers.size>0)&&(notifyComponents(store,storeState,treeState),storeState.suspendedComponentResolvers.forEach(cb=>cb()),storeState.suspendedComponentResolvers.clear())}storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb=>cb(treeState)),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function endBatch(store){let storeState=store.getState();storeState.commitDepth++;try{let{nextTree}=storeState;if(null==nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(store),null!=storeState.previousTree?storeState.graphsByVersion.delete(storeState.previousTree.version):recoverableViolation_1("Ended batch with no previous state, which is unexpected","recoil"),storeState.previousTree=null,Recoil_gkx("recoil_memory_managament_2020")&&null==nextTree&&releaseScheduledRetainablesNow$1(store)}finally{storeState.commitDepth--}}function Batcher({setNotifyBatcherOfChange}){let storeRef=useStoreRef(),[,setState]=useState([]);return setNotifyBatcherOfChange(()=>setState({})),useEffect(()=>(setNotifyBatcherOfChange(()=>setState({})),()=>{setNotifyBatcherOfChange(()=>{})}),[setNotifyBatcherOfChange]),useEffect(()=>{Recoil_Queue.enqueueExecution("Batcher",()=>{endBatch(storeRef.current)})}),null}function initialStoreState_DEPRECATED(store,initializeState){let initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{let state=initial.currentTree,writes=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys()),nonvalidatedAtoms=state.nonvalidatedAtoms.clone();for(let n of writtenNodes)nonvalidatedAtoms.delete(n);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach((v,k)=>{initial.currentTree=setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree,k,v)})}}),initial}function initialStoreState(initializeState){let snapshot=freshSnapshot$1(initializeState),storeState=snapshot.getStore_INTERNAL().getState();return snapshot.retain(),storeState.nodeCleanupFunctions.forEach(cleanup=>cleanup()),storeState.nodeCleanupFunctions.clear(),storeState}let nextID=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED,initializeState,store_INTERNAL:storeProp,children}){let storeStateRef;let getGraph=version=>{let graphs=storeStateRef.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));let newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions=(callback,key)=>{if(null==key){let{transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{let{nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);let id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{let subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata=metadata=>{for(let k of(startNextTreeIfNeeded(storeRef.current),Object.keys(metadata)))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]},replaceState=replacer=>{let replaced;startNextTreeIfNeeded(storeRef.current);let nextTree=Recoil_nullthrows(storeStateRef.current.nextTree);try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeStateRef.current.nextTree=replaced,reactMode$2().early&&notifyComponents(storeRef.current,storeStateRef.current,replaced),Recoil_nullthrows(notifyBatcherOfChange.current)())},notifyBatcherOfChange=useRef$1(null),setNotifyBatcherOfChange=useCallback(x=>{notifyBatcherOfChange.current=x},[notifyBatcherOfChange]),storeRef=Recoil_useRefInitOnce(()=>null!=storeProp?storeProp:{storeID:getNextStoreID$2(),getState:()=>storeStateRef.current,replaceState,getGraph,subscribeToTransactions,addTransactionMetadata});null!=storeProp&&(storeRef.current=storeProp);let mutableSource=useMemo(()=>null==createMutableSource$1?void 0:createMutableSource$1(storeStateRef,()=>storeStateRef.current.currentTree.version),[storeStateRef=Recoil_useRefInitOnce(()=>null!=initializeState_DEPRECATED?initialStoreState_DEPRECATED(storeRef.current,initializeState_DEPRECATED):null!=initializeState?initialStoreState(initializeState):makeEmptyStoreState$2())]);return useEffect(()=>{let store=storeRef.current;for(let atomKey of new Set(store.getState().knownAtoms))initializeNode$2(store,atomKey,"get");return()=>{for(let atomKey of store.getState().knownAtoms)cleanUpNode$2(store,atomKey)}},[storeRef]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(AppContext.Provider,{value:storeRef},react__WEBPACK_IMPORTED_MODULE_0__.createElement(MutableSourceContext.Provider,{value:mutableSource},react__WEBPACK_IMPORTED_MODULE_0__.createElement(Batcher,{setNotifyBatcherOfChange:setNotifyBatcherOfChange}),children))}function useRecoilStoreID(){return useStoreRef().current.storeID}var Recoil_RecoilRoot={RecoilRoot:function RecoilRoot(props){let{override,...propsExceptOverride}=props,ancestorStoreRef=useStoreRef();return!1===override&&ancestorStoreRef.current!==defaultStore?props.children:react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecoilRoot_INTERNAL,propsExceptOverride)},useStoreRef,useRecoilMutableSource:function useRecoilMutableSource(){let mutableSource=useContext(MutableSourceContext);return null==mutableSource&&expectationViolation_1("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),mutableSource},useRecoilStoreID,notifyComponents_FOR_TESTING:notifyComponents,sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications},Recoil_shallowArrayEqual=function shallowArrayEqual(a,b){if(a===b)return!0;if(a.length!==b.length)return!1;for(let i=0,l=a.length;i<l;i++)if(a[i]!==b[i])return!1;return!0};let{useEffect:useEffect$1,useRef:useRef$2}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_usePrevious=function usePrevious(value){let ref=useRef$2();return useEffect$1(()=>{ref.current=value}),ref.current};let{useStoreRef:useStoreRef$1}=Recoil_RecoilRoot,{SUSPENSE_TIMEOUT_MS:SUSPENSE_TIMEOUT_MS$1}=Recoil_Retention,{updateRetainCount:updateRetainCount$2}=Recoil_Retention,{RetentionZone:RetentionZone$3}=Recoil_RetentionZone,{useEffect:useEffect$2,useRef:useRef$3}=react__WEBPACK_IMPORTED_MODULE_0__,{isSSR:isSSR$2}=Recoil_Environment;function useRetain_ACTUAL(toRetain){let retainables=(Array.isArray(toRetain)?toRetain:[toRetain]).map(a=>a instanceof RetentionZone$3?a:a.key),storeRef=useStoreRef$1();useEffect$2(()=>{if(!Recoil_gkx("recoil_memory_managament_2020"))return;let store=storeRef.current;if(timeoutID.current&&!isSSR$2)window.clearTimeout(timeoutID.current),timeoutID.current=null;else for(let r of retainables)updateRetainCount$2(store,r,1);return()=>{for(let r of retainables)updateRetainCount$2(store,r,-1)}},[storeRef,...retainables]);let timeoutID=useRef$3(),previousRetainables=Recoil_usePrevious(retainables);if(!isSSR$2&&(void 0===previousRetainables||!Recoil_shallowArrayEqual(previousRetainables,retainables))){let store=storeRef.current;for(let r of retainables)updateRetainCount$2(store,r,1);if(previousRetainables)for(let r of previousRetainables)updateRetainCount$2(store,r,-1);timeoutID.current&&window.clearTimeout(timeoutID.current),timeoutID.current=window.setTimeout(()=>{for(let r of(timeoutID.current=null,retainables))updateRetainCount$2(store,r,-1)},SUSPENSE_TIMEOUT_MS$1)}}var Recoil_useRetain=function useRetain(toRetain){if(Recoil_gkx("recoil_memory_managament_2020"))return useRetain_ACTUAL(toRetain)},Recoil_useComponentName=function useComponentName(){return"<component name not available>"};let{batchUpdates:batchUpdates$2}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$2}=Recoil_Node,{currentRendererSupportsUseSyncExternalStore:currentRendererSupportsUseSyncExternalStore$1,reactMode:reactMode$3,useMutableSource:useMutableSource$1,useSyncExternalStore:useSyncExternalStore$1}=Recoil_ReactMode,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$2}=Recoil_RecoilRoot,{isRecoilValue:isRecoilValue$2}=Recoil_RecoilValue$1,{AbstractRecoilValue:AbstractRecoilValue$3,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$2,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{useCallback:useCallback$1,useEffect:useEffect$3,useMemo:useMemo$1,useRef:useRef$4,useState:useState$1}=react__WEBPACK_IMPORTED_MODULE_0__,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{isSSR:isSSR$3}=Recoil_Environment;function handleLoadable(loadable,recoilValue,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state)throw new Promise(resolve=>{let suspendedComponentResolvers=storeRef.current.getState().suspendedComponentResolvers;suspendedComponentResolvers.add(resolve),isSSR$3&&Recoil_isPromise(loadable.contents)&&loadable.contents.finally(()=>{suspendedComponentResolvers.delete(resolve)})});if("hasError"===loadable.state)throw loadable.contents;throw err_1(`Invalid value of loadable atom "${recoilValue.key}"`)}function useRecoilInterface_DEPRECATED(){let componentName=Recoil_useComponentName(),storeRef=useStoreRef$2(),[,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$4(new Set);recoilValuesUsed.current=new Set;let previousSubscriptions=useRef$4(new Set),subscriptions=useRef$4(new Map),unsubscribeFrom=useCallback$1(key=>{let sub=subscriptions.current.get(key);sub&&(sub.release(),subscriptions.current.delete(key))},[subscriptions]),updateState=useCallback$1((_state,key)=>{subscriptions.current.has(key)&&forceUpdate([])},[]);return useEffect$3(()=>{let store=storeRef.current;Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach(key=>{if(subscriptions.current.has(key)){expectationViolation_1(`Double subscription to RecoilValue "${key}"`);return}let sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$3(key),state=>updateState(state,key),componentName);subscriptions.current.set(key,sub),store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{updateState(store.getState(),key)}):updateState(store.getState(),key)}),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach(key=>{unsubscribeFrom(key)}),previousSubscriptions.current=recoilValuesUsed.current}),useEffect$3(()=>{let currentSubscriptions=subscriptions.current;return Recoil_differenceSets(recoilValuesUsed.current,new Set(currentSubscriptions.keys())).forEach(key=>{let sub=subscribeToRecoilValue$1(storeRef.current,new AbstractRecoilValue$3(key),state=>updateState(state,key),componentName);currentSubscriptions.set(key,sub)}),()=>currentSubscriptions.forEach((_,key)=>unsubscribeFrom(key))},[componentName,storeRef,unsubscribeFrom,updateState]),useMemo$1(()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){var _storeState$nextTree;recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key));let storeState=storeRef.current.getState();return getRecoilValueAsLoadable$2(storeRef.current,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useRecoilState(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]}function useRecoilStateLoadable(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:useRecoilState,getRecoilStateLoadable:useRecoilStateLoadable,getSetRecoilState:useSetRecoilState,getResetRecoilState:function useResetRecoilState(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}},[recoilValuesUsed,storeRef])}function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue){let storeRef=useStoreRef$2(),componentName=Recoil_useComponentName(),getSnapshot=useCallback$1(()=>{var _storeState$nextTree2;let store=storeRef.current,storeState=store.getState();return{loadable:getRecoilValueAsLoadable$2(store,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree2=storeState.nextTree)&&void 0!==_storeState$nextTree2?_storeState$nextTree2:storeState.currentTree),key:recoilValue.key}},[storeRef,recoilValue]),memoizePreviousSnapshot=useCallback$1(getState=>{let prevState;return()=>{var _prevState,_prevState2;let nextState=getState();return null!==(_prevState=prevState)&&void 0!==_prevState&&_prevState.loadable.is(nextState.loadable)&&(null===(_prevState2=prevState)||void 0===_prevState2?void 0:_prevState2.key)===nextState.key?prevState:(prevState=nextState,nextState)}},[]),getMemoizedSnapshot=useMemo$1(()=>memoizePreviousSnapshot(getSnapshot),[getSnapshot,memoizePreviousSnapshot]);return useSyncExternalStore$1(useCallback$1(notify=>subscribeToRecoilValue$1(storeRef.current,recoilValue,notify,componentName).release,[storeRef,recoilValue,componentName]),getMemoizedSnapshot,getMemoizedSnapshot).loadable}function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue){let storeRef=useStoreRef$2(),getLoadable=useCallback$1(()=>{var _storeState$nextTree3;let store=storeRef.current,storeState=store.getState();return getRecoilValueAsLoadable$2(store,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree3=storeState.nextTree)&&void 0!==_storeState$nextTree3?_storeState$nextTree3:storeState.currentTree)},[storeRef,recoilValue]),getLoadableWithTesting=useCallback$1(()=>getLoadable(),[getLoadable]),componentName=Recoil_useComponentName(),subscribe=useCallback$1((_storeState,notify)=>subscribeToRecoilValue$1(storeRef.current,recoilValue,()=>{if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return notify();let newLoadable=getLoadable();prevLoadableRef.current.is(newLoadable)||notify(),prevLoadableRef.current=newLoadable},componentName).release,[storeRef,recoilValue,componentName,getLoadable]),source=useRecoilMutableSource$1();if(null==source)throw err_1("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let loadable=useMutableSource$1(source,getLoadableWithTesting,subscribe),prevLoadableRef=useRef$4(loadable);return useEffect$3(()=>{prevLoadableRef.current=loadable}),loadable}function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue){let storeRef=useStoreRef$2(),componentName=Recoil_useComponentName(),getLoadable=useCallback$1(()=>{var _storeState$nextTree4;let store=storeRef.current,storeState=store.getState();return getRecoilValueAsLoadable$2(store,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree4=storeState.nextTree)&&void 0!==_storeState$nextTree4?_storeState$nextTree4:storeState.currentTree)},[storeRef,recoilValue]),getState=useCallback$1(()=>({loadable:getLoadable(),key:recoilValue.key}),[getLoadable,recoilValue.key]),updateState=useCallback$1(prevState=>{let nextState=getState();return prevState.loadable.is(nextState.loadable)&&prevState.key===nextState.key?prevState:nextState},[getState]);useEffect$3(()=>{let subscription=subscribeToRecoilValue$1(storeRef.current,recoilValue,_state=>{setState(updateState)},componentName);return setState(updateState),subscription.release},[componentName,recoilValue,storeRef,updateState]);let[state,setState]=useState$1(getState);return state.key!==recoilValue.key?getState().loadable:state.loadable}function useRecoilValueLoadable_LEGACY(recoilValue){let storeRef=useStoreRef$2(),[,forceUpdate]=useState$1([]),componentName=Recoil_useComponentName(),getLoadable=useCallback$1(()=>{var _storeState$nextTree5;let store=storeRef.current,storeState=store.getState();return getRecoilValueAsLoadable$2(store,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree5=storeState.nextTree)&&void 0!==_storeState$nextTree5?_storeState$nextTree5:storeState.currentTree)},[storeRef,recoilValue]),loadable=getLoadable(),prevLoadableRef=useRef$4(loadable);return useEffect$3(()=>{prevLoadableRef.current=loadable}),useEffect$3(()=>{let store=storeRef.current,storeState=store.getState(),subscription=subscribeToRecoilValue$1(store,recoilValue,_state=>{var _prevLoadableRef$curr;if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return forceUpdate([]);let newLoadable=getLoadable();null!==(_prevLoadableRef$curr=prevLoadableRef.current)&&void 0!==_prevLoadableRef$curr&&_prevLoadableRef$curr.is(newLoadable)||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable},componentName);if(storeState.nextTree)store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{prevLoadableRef.current=null,forceUpdate([])});else{var _prevLoadableRef$curr2;if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return forceUpdate([]);let newLoadable=getLoadable();null!==(_prevLoadableRef$curr2=prevLoadableRef.current)&&void 0!==_prevLoadableRef$curr2&&_prevLoadableRef$curr2.is(newLoadable)||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable}return subscription.release},[componentName,getLoadable,recoilValue,storeRef]),loadable}function useRecoilValueLoadable(recoilValue){return Recoil_gkx("recoil_memory_managament_2020")&&Recoil_useRetain(recoilValue),({TRANSITION_SUPPORT:useRecoilValueLoadable_TRANSITION_SUPPORT,SYNC_EXTERNAL_STORE:currentRendererSupportsUseSyncExternalStore$1()?useRecoilValueLoadable_SYNC_EXTERNAL_STORE:useRecoilValueLoadable_TRANSITION_SUPPORT,MUTABLE_SOURCE:useRecoilValueLoadable_MUTABLE_SOURCE,LEGACY:useRecoilValueLoadable_LEGACY})[reactMode$3().mode](recoilValue)}function useRecoilValue(recoilValue){let storeRef=useStoreRef$2();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){let storeRef=useStoreRef$2();return useCallback$1(newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)},[storeRef,recoilState])}function useResetRecoilState(recoilState){let storeRef=useStoreRef$2();return useCallback$1(()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)},[storeRef,recoilState])}function useRecoilState(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]}function useRecoilStateLoadable(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]}function useSetUnvalidatedAtomValues(){let storeRef=useStoreRef$2();return(values,transactionMetadata={})=>{batchUpdates$2(()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach((value,key)=>setUnvalidatedRecoilValue$2(storeRef.current,new AbstractRecoilValue$3(key),value))})}}function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue){return Recoil_gkx("recoil_memory_managament_2020")&&Recoil_useRetain(recoilValue),useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue)}function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue){let storeRef=useStoreRef$2();return handleLoadable(useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue),recoilValue,storeRef)}function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState){return[useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState),useSetRecoilState(recoilState)]}var Recoil_filterMap=function filterMap(map,callback){let result=new Map;for(let[key,value]of map)callback(value,key)&&result.set(key,value);return result},Recoil_filterSet=function filterSet(set,callback){let result=new Set;for(let value of set)callback(value)&&result.add(value);return result},Recoil_mergeMaps=function mergeMaps(...maps){let result=new Map;for(let i=0;i<maps.length;i++){let nextKey;let iterator=maps[i].keys();for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};let{batchUpdates:batchUpdates$3}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$3,getNode:getNode$4,nodes:nodes$1}=Recoil_Node,{useStoreRef:useStoreRef$3}=Recoil_RecoilRoot,{AbstractRecoilValue:AbstractRecoilValue$4,setRecoilValueLoadable:setRecoilValueLoadable$1}=Recoil_RecoilValueInterface,{SUSPENSE_TIMEOUT_MS:SUSPENSE_TIMEOUT_MS$2}=Recoil_Retention,{cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{useCallback:useCallback$2,useEffect:useEffect$4,useRef:useRef$5,useState:useState$2}=react__WEBPACK_IMPORTED_MODULE_0__,{isSSR:isSSR$4}=Recoil_Environment;function useTransactionSubscription(callback){let storeRef=useStoreRef$3();useEffect$4(()=>storeRef.current.subscribeToTransactions(callback).release,[callback,storeRef])}function externallyVisibleAtomValuesInState(state){let persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(state.atomValues.toMap(),(v,k)=>{let persistence=getNode$4(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state}),v=>v.contents);return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(),persistedAtomContentsValues)}function gotoSnapshot(store,snapshot){var _storeState$nextTree;let storeState=store.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$3(()=>{let keysToUpdate=new Set;for(let keys of[prev.atomValues.keys(),next.atomValues.keys()])for(let key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$4(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach(key=>{setRecoilValueLoadable$1(store,new AbstractRecoilValue$4(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$3)}),store.replaceState(state=>({...state,stateID:snapshot.getID()}))})}function useGotoRecoilSnapshot(){let storeRef=useStoreRef$3();return useCallback$2(snapshot=>gotoSnapshot(storeRef.current,snapshot),[storeRef])}var Recoil_SnapshotHooks={useRecoilSnapshot:function useRecoilSnapshot(){let storeRef=useStoreRef$3(),[snapshot,setSnapshot]=useState$2(()=>cloneSnapshot$1(storeRef.current)),previousSnapshot=Recoil_usePrevious(snapshot),timeoutID=useRef$5(),releaseRef=useRef$5();if(useTransactionSubscription(useCallback$2(store=>setSnapshot(cloneSnapshot$1(store)),[])),useEffect$4(()=>{let release=snapshot.retain();if(timeoutID.current&&!isSSR$4){var _releaseRef$current;window.clearTimeout(timeoutID.current),timeoutID.current=null,null===(_releaseRef$current=releaseRef.current)||void 0===_releaseRef$current||_releaseRef$current.call(releaseRef),releaseRef.current=null}return()=>{window.setTimeout(release,10)}},[snapshot]),previousSnapshot!==snapshot&&!isSSR$4){if(timeoutID.current){var _releaseRef$current2;window.clearTimeout(timeoutID.current),timeoutID.current=null,null===(_releaseRef$current2=releaseRef.current)||void 0===_releaseRef$current2||_releaseRef$current2.call(releaseRef),releaseRef.current=null}releaseRef.current=snapshot.retain(),timeoutID.current=window.setTimeout(()=>{var _releaseRef$current3;timeoutID.current=null,null===(_releaseRef$current3=releaseRef.current)||void 0===_releaseRef$current3||_releaseRef$current3.call(releaseRef),releaseRef.current=null},SUSPENSE_TIMEOUT_MS$2)}return snapshot},gotoSnapshot,useGotoRecoilSnapshot,useRecoilTransactionObserver:function useRecoilTransactionObserver(callback){useTransactionSubscription(useCallback$2(store=>{callback({snapshot:cloneSnapshot$1(store,"latest"),previousSnapshot:cloneSnapshot$1(store,"previous")})},[callback]))},useTransactionObservation_DEPRECATED:function useTransactionObservation_DEPRECATED(callback){useTransactionSubscription(useCallback$2(store=>{let previousTree=store.getState().previousTree,currentTree=store.getState().currentTree;previousTree||(recoverableViolation_1("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),previousTree=store.getState().currentTree);let atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}}),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,k=>atomValues.has(k)||previousAtomValues.has(k));callback({atomValues,previousAtomValues,atomInfo,modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})},[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};let{peekNodeInfo:peekNodeInfo$2}=Recoil_FunctionalCore,{useStoreRef:useStoreRef$4}=Recoil_RecoilRoot,{reactMode:reactMode$4}=Recoil_ReactMode,{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$5}=Recoil_RecoilRoot,{useMemo:useMemo$2}=react__WEBPACK_IMPORTED_MODULE_0__,{loadableWithValue:loadableWithValue$1}=Recoil_Loadable$1,{initializeNode:initializeNode$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$4,getNode:getNode$5}=Recoil_Node,{copyTreeState:copyTreeState$1,getRecoilValueAsLoadable:getRecoilValueAsLoadable$3,invalidateDownstreams:invalidateDownstreams$1,writeLoadableToTreeState:writeLoadableToTreeState$1}=Recoil_RecoilValueInterface;function isAtom(recoilValue){return"atom"===getNode$5(recoilValue.key).nodeType}class TransactionInterfaceImpl{constructor(store,treeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"_treeState",void 0),_defineProperty(this,"_changes",void 0),_defineProperty(this,"get",recoilValue=>{if(this._changes.has(recoilValue.key))return this._changes.get(recoilValue.key);if(!isAtom(recoilValue))throw err_1("Reading selectors within atomicUpdate is not supported");let loadable=getRecoilValueAsLoadable$3(this._store,recoilValue,this._treeState);if("hasValue"===loadable.state)return loadable.contents;if("hasError"===loadable.state)throw loadable.contents;throw err_1(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`)}),_defineProperty(this,"set",(recoilState,valueOrUpdater)=>{if(!isAtom(recoilState))throw err_1("Setting selectors within atomicUpdate is not supported");if("function"==typeof valueOrUpdater){let current=this.get(recoilState);this._changes.set(recoilState.key,valueOrUpdater(current))}else initializeNode$3(this._store,recoilState.key,"set"),this._changes.set(recoilState.key,valueOrUpdater)}),_defineProperty(this,"reset",recoilState=>{this.set(recoilState,DEFAULT_VALUE$4)}),this._store=store,this._treeState=treeState,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;let newState=copyTreeState$1(this._treeState);for(let[k,v]of this._changes)writeLoadableToTreeState$1(newState,k,loadableWithValue$1(v));return invalidateDownstreams$1(this._store,newState),newState}}var Recoil_AtomicUpdates$1=Object.freeze({__proto__:null,atomicUpdater:function atomicUpdater(store){return fn=>{store.replaceState(treeState=>{let changeset=new TransactionInterfaceImpl(store,treeState);return fn(changeset),changeset.newTreeState_INTERNAL()})}}}),invariant_1=function invariant(condition,message){if(!condition)throw Error(message)};let{atomicUpdater:atomicUpdater$1}=Recoil_AtomicUpdates$1,{batchUpdates:batchUpdates$4}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$5}=Recoil_Node,{useStoreRef:useStoreRef$6}=Recoil_RecoilRoot,{refreshRecoilValue:refreshRecoilValue$1,setRecoilValue:setRecoilValue$3}=Recoil_RecoilValueInterface,{cloneSnapshot:cloneSnapshot$2}=Recoil_Snapshot$1,{gotoSnapshot:gotoSnapshot$1}=Recoil_SnapshotHooks,{useCallback:useCallback$3}=react__WEBPACK_IMPORTED_MODULE_0__;class Sentinel{}let SENTINEL=new Sentinel;function recoilCallback(store,fn,args,extraInterface){let releaseSnapshot,ret=SENTINEL;if(batchUpdates$4(()=>{let errMsg="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof fn)throw err_1(errMsg);let callback=fn(Recoil_lazyProxy({...null!=extraInterface?extraInterface:{},set:(node,newValue)=>setRecoilValue$3(store,node,newValue),reset:node=>setRecoilValue$3(store,node,DEFAULT_VALUE$5),refresh:node=>refreshRecoilValue$1(store,node),gotoSnapshot:snapshot=>gotoSnapshot$1(store,snapshot),transact_UNSTABLE:transaction=>atomicUpdater$1(store)(transaction)},{snapshot:()=>{let snapshot=cloneSnapshot$2(store);return releaseSnapshot=snapshot.retain(),snapshot}}));if("function"!=typeof callback)throw err_1(errMsg);ret=callback(...args)}),ret instanceof Sentinel&&invariant_1(!1),Recoil_isPromise(ret))ret=ret.finally(()=>{var _releaseSnapshot;null===(_releaseSnapshot=releaseSnapshot)||void 0===_releaseSnapshot||_releaseSnapshot()});else{var _releaseSnapshot2;null===(_releaseSnapshot2=releaseSnapshot)||void 0===_releaseSnapshot2||_releaseSnapshot2()}return ret}function useRecoilCallback(fn,deps){let storeRef=useStoreRef$6();return useCallback$3((...args)=>recoilCallback(storeRef.current,fn,args),null!=deps?[...deps,storeRef]:void 0)}var Recoil_useRecoilCallback={recoilCallback,useRecoilCallback};let{useStoreRef:useStoreRef$7}=Recoil_RecoilRoot,{refreshRecoilValue:refreshRecoilValue$2}=Recoil_RecoilValueInterface,{useCallback:useCallback$4}=react__WEBPACK_IMPORTED_MODULE_0__,{atomicUpdater:atomicUpdater$2}=Recoil_AtomicUpdates$1,{useStoreRef:useStoreRef$8}=Recoil_RecoilRoot,{useMemo:useMemo$3}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_Wrapper$1=Object.freeze({__proto__:null,WrappedValue:{WrappedValue:class{constructor(value){_defineProperty(this,"value",void 0),this.value=value}}}.WrappedValue});let{isFastRefreshEnabled:isFastRefreshEnabled$2}=Recoil_ReactMode;class ChangedPathError extends Error{}var Recoil_TreeCache$1=Object.freeze({__proto__:null,TreeCache:{TreeCache:class{constructor(options){var _options$onHit,_options$onSet,_options$mapNodeValue;_defineProperty(this,"_name",void 0),_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._name=null==options?void 0:options.name,this._numLeafs=0,this._root=null,this._onHit=null!==(_options$onHit=null==options?void 0:options.onHit)&&void 0!==_options$onHit?_options$onHit:()=>{},this._onSet=null!==(_options$onSet=null==options?void 0:options.onSet)&&void 0!==_options$onSet?_options$onSet:()=>{},this._mapNodeValue=null!==(_options$mapNodeValue=null==options?void 0:options.mapNodeValue)&&void 0!==_options$mapNodeValue?_options$mapNodeValue:val=>val}size(){return this._numLeafs}root(){return this._root}get(getNodeValue,handlers){var _this$getLeafNode;return null===(_this$getLeafNode=this.getLeafNode(getNodeValue,handlers))||void 0===_this$getLeafNode?void 0:_this$getLeafNode.value}getLeafNode(getNodeValue,handlers){if(null==this._root)return;let node=this._root;for(;node;){if(null==handlers||handlers.onNodeVisit(node),"leaf"===node.type)return this._onHit(node),node;let nodeValue=this._mapNodeValue(getNodeValue(node.nodeKey));node=node.branches.get(nodeValue)}}set(route,value,handlers){let addLeaf=()=>{var _node2,_node3,_this$_root2,_handlers$onNodeVisit2,_node,_handlers$onNodeVisit,_this$_root;let node,branchKey;for(let[nodeKey,nodeValue]of route){let root=this._root;if((null==root?void 0:root.type)==="leaf")throw this.invalidCacheError();let parent=node;if("branch"!==(node=null!==(_node=node=parent?parent.branches.get(branchKey):root)&&void 0!==_node?_node:{type:"branch",nodeKey,parent,branches:new Map,branchKey}).type||node.nodeKey!==nodeKey)throw this.invalidCacheError();null==parent||parent.branches.set(branchKey,node),null==handlers||null===(_handlers$onNodeVisit=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit||_handlers$onNodeVisit.call(handlers,node),branchKey=this._mapNodeValue(nodeValue),this._root=null!==(_this$_root=this._root)&&void 0!==_this$_root?_this$_root:node}let oldLeaf=node?null===(_node2=node)||void 0===_node2?void 0:_node2.branches.get(branchKey):this._root;if(null!=oldLeaf&&("leaf"!==oldLeaf.type||oldLeaf.branchKey!==branchKey))throw this.invalidCacheError();let leafNode={type:"leaf",value,parent:node,branchKey};null===(_node3=node)||void 0===_node3||_node3.branches.set(branchKey,leafNode),this._root=null!==(_this$_root2=this._root)&&void 0!==_this$_root2?_this$_root2:leafNode,this._numLeafs++,this._onSet(leafNode),null==handlers||null===(_handlers$onNodeVisit2=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit2||_handlers$onNodeVisit2.call(handlers,leafNode)};try{addLeaf()}catch(error){if(error instanceof ChangedPathError)this.clear(),addLeaf();else throw error}}delete(leaf){let root=this.root();if(!root)return!1;if(leaf===root)return this._root=null,this._numLeafs=0,!0;let node=leaf.parent,branchKey=leaf.branchKey;for(;node;){var _node4;if(node.branches.delete(branchKey),node===root)return 0===node.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(node.branches.size>0)break;branchKey=null===(_node4=node)||void 0===_node4?void 0:_node4.branchKey,node=node.parent}for(;node!==root;node=node.parent)if(null==node)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){throw recoverableViolation_1((isFastRefreshEnabled$2()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.")+(null!=this._name?` - ${this._name}`:"")),new ChangedPathError}}}.TreeCache}),Recoil_LRUCache$1=Object.freeze({__proto__:null,LRUCache:{LRUCache:class{constructor(options){var _options$mapKey;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=options.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(_options$mapKey=options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(key){return this._map.has(this._keyMapper(key))}get(key){let mappedKey=this._keyMapper(key),node=this._map.get(mappedKey);if(node)return this.set(key,node.value),node.value}set(key,val){let mappedKey=this._keyMapper(key);this._map.get(mappedKey)&&this.delete(key);let head=this.head(),node={key,right:head,left:null,value:val};head?head.left=node:this._tail=node,this._map.set(mappedKey,node),this._head=node,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let tail=this.tail();tail&&this.delete(tail.key)}delete(key){let mappedKey=this._keyMapper(key);if(!this._size||!this._map.has(mappedKey))return;let node=Recoil_nullthrows(this._map.get(mappedKey)),right=node.right,left=node.left;right&&(right.left=node.left),left&&(left.right=node.right),node===this.head()&&(this._head=right),node===this.tail()&&(this._tail=left),this._map.delete(mappedKey),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}}.LRUCache});let{LRUCache:LRUCache$1}=Recoil_LRUCache$1,{TreeCache:TreeCache$1}=Recoil_TreeCache$1;var Recoil_treeCacheLRU=function treeCacheLRU({name,maxSize,mapNodeValue=v=>v}){let lruCache=new LRUCache$1({maxSize}),cache=new TreeCache$1({name,mapNodeValue,onHit:node=>{lruCache.set(node,!0)},onSet:node=>{let lruNode=lruCache.tail();lruCache.set(node,!0),lruNode&&cache.size()>maxSize&&cache.delete(lruNode.key)}});return cache};function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if((null==opt?void 0:opt.allowFunctions)!==!0)throw err_1("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";if("object"!=typeof x){var _JSON$stringify;return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:""}if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map((v,i)=>stringify(v,opt,i.toString()))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){let obj={};for(let[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt))),opt,key):void 0!==Symbol&&null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter(k=>void 0!==x[k]).sort().map(k=>`${stringify(k,opt)}:${stringify(x[k],opt,k)}`).join(",")}}`}var Recoil_stableStringify=function stableStringify(x,opt={allowFunctions:!1}){return stringify(x,opt)};let{TreeCache:TreeCache$2}=Recoil_TreeCache$1,defaultPolicy={equality:"reference",eviction:"keep-all",maxSize:1/0};function getValueMapper(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw err_1(`Unrecognized equality policy ${equality}`)}function getTreeCache(eviction,maxSize,mapNodeValue,name){switch(eviction){case"keep-all":return new TreeCache$2({name,mapNodeValue});case"lru":return Recoil_treeCacheLRU({name,maxSize:Recoil_nullthrows(maxSize),mapNodeValue});case"most-recent":return Recoil_treeCacheLRU({name,maxSize:1,mapNodeValue})}throw err_1(`Unrecognized eviction policy ${eviction}`)}let{isReactNative:isReactNative$1,isWindow:isWindow$1}=Recoil_Environment,{isLoadable:isLoadable$1,loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$2}=Recoil_Loadable$1,{WrappedValue:WrappedValue$1}=Recoil_Wrapper$1,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$1,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{saveDepsToStore:saveDepsToStore$1}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$6,getConfigDeletionHandler:getConfigDeletionHandler$1,getNode:getNode$6,registerNode:registerNode$1}=Recoil_Node,{isRecoilValue:isRecoilValue$3}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$1}=Recoil_Retention,{recoilCallback:recoilCallback$1}=Recoil_useRecoilCallback,{startPerfBlock:startPerfBlock$1}={startPerfBlock:function startPerfBlock(_id){return()=>null}};class Canceled{}let CANCELED=new Canceled,dependencyStack=[],waitingStores=new Map,getNewExecutionID=(()=>{let executionID=0;return()=>executionID++})();function selector(options){let recoilValue=null,{key,get,cachePolicy_UNSTABLE:cachePolicy}=options,set=null!=options.set?options.set:void 0,discoveredDependencyNodeKeys=new Set,cache=function treeCacheFromPolicy({equality=defaultPolicy.equality,eviction=defaultPolicy.eviction,maxSize=defaultPolicy.maxSize}=defaultPolicy,name){return getTreeCache(eviction,maxSize,getValueMapper(equality),name)}(null!=cachePolicy?cachePolicy:{equality:"reference",eviction:"keep-all"},key),retainedBy=retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE),executionInfoMap=new Map,liveStoresCount=0;function selectorIsLive(){return!Recoil_gkx("recoil_memory_managament_2020")||liveStoresCount>0}function selectorInit(store){return store.getState().knownSelectors.add(key),liveStoresCount++,()=>{liveStoresCount--}}function selectorShouldDeleteConfigOnRelease(){return void 0!==getConfigDeletionHandler$1(key)&&!selectorIsLive()}function notifyStoresOfResolvedAsync(store,executionID){isLatestExecution(store,executionID)&&clearExecutionInfo(store),notifyWaitingStores(executionID,!0)}function notifyStoresOfNewAsyncDep(store,executionID){isLatestExecution(store,executionID)&&(Recoil_nullthrows(getExecutionInfo(store)).stateVersions.clear(),notifyWaitingStores(executionID,!1))}function notifyWaitingStores(executionID,clearWaitlist){let stores=waitingStores.get(executionID);if(null!=stores){for(let waitingStore of stores)markRecoilValueModified$1(waitingStore,Recoil_nullthrows(recoilValue));clearWaitlist&&waitingStores.delete(executionID)}}function markStoreWaitingForResolvedAsync(store,executionID){let stores=waitingStores.get(executionID);null==stores&&waitingStores.set(executionID,stores=new Set),stores.add(store)}function wrapResultPromise(store,promise,state,depValues,executionID,loadingDepsState){return promise.then(value=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;return setCache(state,loadableWithValue$2(value),depValues),notifyStoresOfResolvedAsync(store,executionID),value}).catch(errorOrPromise=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;if(Recoil_isPromise(errorOrPromise))return wrapPendingDependencyPromise(store,errorOrPromise,state,depValues,executionID,loadingDepsState);throw setCache(state,loadableWithError$1(errorOrPromise),depValues),notifyStoresOfResolvedAsync(store,executionID),errorOrPromise})}function wrapPendingDependencyPromise(store,promise,state,existingDeps,executionID,loadingDepsState){return promise.then(resolvedDep=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;null!=loadingDepsState.loadingDepKey&&loadingDepsState.loadingDepPromise===promise?state.atomValues.set(loadingDepsState.loadingDepKey,loadableWithValue$2(resolvedDep)):store.getState().knownSelectors.forEach(nodeKey=>{state.atomValues.delete(nodeKey)});let cachedLoadable=getLoadableFromCacheAndUpdateDeps(store,state);if(cachedLoadable&&"loading"!==cachedLoadable.state){if((isLatestExecution(store,executionID)||null==getExecutionInfo(store))&&notifyStoresOfResolvedAsync(store,executionID),"hasValue"===cachedLoadable.state)return cachedLoadable.contents;throw cachedLoadable.contents}if(!isLatestExecution(store,executionID)){let executionInfo=getInProgressExecutionInfo(store,state);if(null!=executionInfo)return executionInfo.loadingLoadable.contents}let[loadable,depValues]=evaluateSelectorGetter(store,state,executionID);if("loading"!==loadable.state&&(setCache(state,loadable,depValues),notifyStoresOfResolvedAsync(store,executionID)),"hasError"===loadable.state)throw loadable.contents;return loadable.contents}).catch(error=>{if(error instanceof Canceled)throw CANCELED;if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;throw setCache(state,loadableWithError$1(error),existingDeps),notifyStoresOfResolvedAsync(store,executionID),error})}function updateDeps(store,state,deps,executionID){var _store$getState,_store$getState$curre,_store$getState2,_store$getState2$next,_store$getState$nextT,_store$getState3,_store$getState3$next;for(let nodeKey of((isLatestExecution(store,executionID)||state.version===(null===(_store$getState=store.getState())||void 0===_store$getState?void 0:null===(_store$getState$curre=_store$getState.currentTree)||void 0===_store$getState$curre?void 0:_store$getState$curre.version)||state.version===(null===(_store$getState2=store.getState())||void 0===_store$getState2?void 0:null===(_store$getState2$next=_store$getState2.nextTree)||void 0===_store$getState2$next?void 0:_store$getState2$next.version))&&saveDepsToStore$1(key,deps,store,null!==(_store$getState$nextT=null===(_store$getState3=store.getState())||void 0===_store$getState3?void 0:null===(_store$getState3$next=_store$getState3.nextTree)||void 0===_store$getState3$next?void 0:_store$getState3$next.version)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree.version),deps))discoveredDependencyNodeKeys.add(nodeKey)}function evaluateSelectorGetter(store,state,executionID){let result,loadable;let endPerfBlock=startPerfBlock$1(key),duringSynchronousExecution=!0,duringAsynchronousExecution=!0,finishEvaluation=()=>{endPerfBlock(),duringAsynchronousExecution=!1},resultIsError=!1,loadingDepsState={loadingDepKey:null,loadingDepPromise:null},depValues=new Map;function getRecoilValue({key:depKey}){let depLoadable=getNodeLoadable$2(store,state,depKey);switch(depValues.set(depKey,depLoadable),duringSynchronousExecution||(updateDeps(store,state,new Set(depValues.keys()),executionID),notifyStoresOfNewAsyncDep(store,executionID)),depLoadable.state){case"hasValue":return depLoadable.contents;case"hasError":throw depLoadable.contents;case"loading":throw loadingDepsState.loadingDepKey=depKey,loadingDepsState.loadingDepPromise=depLoadable.contents,depLoadable.contents}throw err_1("Invalid Loadable state")}try{result=get({get:getRecoilValue,getCallback:fn=>(...args)=>{if(duringAsynchronousExecution)throw err_1("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null!=recoilValue||invariant_1(!1),recoilCallback$1(store,fn,args,{node:recoilValue})}}),result=isRecoilValue$3(result)?getRecoilValue(result):result,isLoadable$1(result)&&("hasError"===result.state&&(resultIsError=!0),result=result.contents),Recoil_isPromise(result)?result=wrapResultPromise(store,result,state,depValues,executionID,loadingDepsState).finally(finishEvaluation):finishEvaluation(),result=result instanceof WrappedValue$1?result.value:result}catch(errorOrDepPromise){Recoil_isPromise(result=errorOrDepPromise)?result=wrapPendingDependencyPromise(store,result,state,depValues,executionID,loadingDepsState).finally(finishEvaluation):(resultIsError=!0,finishEvaluation())}return loadable=resultIsError?loadableWithError$1(result):Recoil_isPromise(result)?loadableWithPromise$1(result):loadableWithValue$2(result),duringSynchronousExecution=!1,updateExecutionInfoDepValues(store,executionID,depValues),updateDeps(store,state,new Set(depValues.keys()),executionID),[loadable,depValues]}function getLoadableFromCacheAndUpdateDeps(store,state){let cachedLoadable=state.atomValues.get(key);if(null!=cachedLoadable)return cachedLoadable;let depsAfterCacheLookup=new Set;try{cachedLoadable=cache.get(nodeKey=>("string"!=typeof nodeKey&&invariant_1(!1),getNodeLoadable$2(store,state,nodeKey).contents),{onNodeVisit:node=>{"branch"===node.type&&node.nodeKey!==key&&depsAfterCacheLookup.add(node.nodeKey)}})}catch(error){throw err_1(`Problem with cache lookup for selector "${key}": ${error.message}`)}if(cachedLoadable){var _getExecutionInfo;state.atomValues.set(key,cachedLoadable),updateDeps(store,state,depsAfterCacheLookup,null===(_getExecutionInfo=getExecutionInfo(store))||void 0===_getExecutionInfo?void 0:_getExecutionInfo.executionID)}return cachedLoadable}function getSelectorLoadableAndUpdateDeps(store,state){let cachedVal=getLoadableFromCacheAndUpdateDeps(store,state);if(null!=cachedVal)return clearExecutionInfo(store),cachedVal;let inProgressExecutionInfo=getInProgressExecutionInfo(store,state);if(null!=inProgressExecutionInfo){var _inProgressExecutionI;return(null===(_inProgressExecutionI=inProgressExecutionInfo.loadingLoadable)||void 0===_inProgressExecutionI?void 0:_inProgressExecutionI.state)==="loading"&&markStoreWaitingForResolvedAsync(store,inProgressExecutionInfo.executionID),inProgressExecutionInfo.loadingLoadable}let newExecutionID=getNewExecutionID(),[loadable,newDepValues]=evaluateSelectorGetter(store,state,newExecutionID);return"loading"===loadable.state?(setExecutionInfo(store,newExecutionID,loadable,newDepValues,state),markStoreWaitingForResolvedAsync(store,newExecutionID)):(clearExecutionInfo(store),setCache(state,loadable,newDepValues)),loadable}function getInProgressExecutionInfo(store,state){function anyDepChanged(execDepValues){for(let[depKey,execLoadable]of execDepValues)if(!getNodeLoadable$2(store,state,depKey).is(execLoadable))return!0;return!1}for(let execInfo of Recoil_concatIterables([executionInfoMap.has(store)?[Recoil_nullthrows(executionInfoMap.get(store))]:[],Recoil_mapIterable(Recoil_filterIterable(executionInfoMap,([s])=>s!==store),([,execInfo])=>execInfo)])){if(execInfo.stateVersions.get(state.version)||!anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork))return execInfo.stateVersions.set(state.version,!0),execInfo;execInfo.stateVersions.set(state.version,!1)}}function getExecutionInfo(store){return executionInfoMap.get(store)}function setExecutionInfo(store,newExecutionID,loadable,depValues,state){executionInfoMap.set(store,{depValuesDiscoveredSoFarDuringAsyncWork:depValues,executionID:newExecutionID,loadingLoadable:loadable,stateVersions:new Map([[state.version,!0]])})}function updateExecutionInfoDepValues(store,executionID,depValues){if(isLatestExecution(store,executionID)){let executionInfo=getExecutionInfo(store);null!=executionInfo&&(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues)}}function clearExecutionInfo(store){executionInfoMap.delete(store)}function isLatestExecution(store,executionID){var _getExecutionInfo2;return executionID===(null===(_getExecutionInfo2=getExecutionInfo(store))||void 0===_getExecutionInfo2?void 0:_getExecutionInfo2.executionID)}function depValuesToDepRoute(depValues){return Array.from(depValues.entries()).map(([depKey,valLoadable])=>[depKey,valLoadable.contents])}function setCache(state,loadable,depValues){state.atomValues.set(key,loadable);try{cache.set(depValuesToDepRoute(depValues),loadable)}catch(error){throw err_1(`Problem with setting cache for selector "${key}": ${error.message}`)}}function detectCircularDependencies(fn){if(dependencyStack.includes(key))return loadableWithError$1(err_1(`Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(" → ")}`));dependencyStack.push(key);try{return fn()}finally{dependencyStack.pop()}}function selectorPeek(store,state){let cachedLoadable=state.atomValues.get(key);return null!=cachedLoadable?cachedLoadable:cache.get(nodeKey=>{var _peekNodeLoadable;return"string"!=typeof nodeKey&&invariant_1(!1),null===(_peekNodeLoadable=peekNodeLoadable$1(store,state,nodeKey))||void 0===_peekNodeLoadable?void 0:_peekNodeLoadable.contents})}function selectorGet(store,state){return detectCircularDependencies(()=>getSelectorLoadableAndUpdateDeps(store,state))}function invalidateSelector(state){state.atomValues.delete(key)}function clearSelectorCache(store,treeState){for(let nodeKey of(null!=recoilValue||invariant_1(!1),discoveredDependencyNodeKeys)){var _node$clearCache;let node=getNode$6(nodeKey);null===(_node$clearCache=node.clearCache)||void 0===_node$clearCache||_node$clearCache.call(node,store,treeState)}discoveredDependencyNodeKeys.clear(),invalidateSelector(treeState),cache.clear(),markRecoilValueModified$1(store,recoilValue)}return recoilValue=null!=set?registerNode$1({key,nodeType:"selector",peek:selectorPeek,get:selectorGet,set:(store,state,newValue)=>{let syncSelectorSetFinished=!1,writes=new Map;function getRecoilValue({key:depKey}){if(syncSelectorSetFinished)throw err_1("Recoil: Async selector sets are not currently supported.");let loadable=getNodeLoadable$2(store,state,depKey);if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){let msg=`Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key}" is not yet supported.`;throw recoverableViolation_1(msg),err_1(msg)}throw loadable.contents}function setRecoilState(recoilState,valueOrUpdater){if(syncSelectorSetFinished){let msg="Recoil: Async selector sets are not currently supported.";throw recoverableViolation_1(msg),err_1(msg)}let setValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater;setNodeValue$3(store,state,recoilState.key,setValue).forEach((v,k)=>writes.set(k,v))}function resetRecoilState(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$6)}let ret=set({set:setRecoilState,get:getRecoilValue,reset:resetRecoilState},newValue);if(void 0!==ret)throw err_1(Recoil_isPromise(ret)?"Recoil: Async selector sets are not currently supported.":"Recoil: selector set should be a void function.");return syncSelectorSetFinished=!0,writes},init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy}):registerNode$1({key,nodeType:"selector",peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy})}selector.value=value=>new WrappedValue$1(value);var Recoil_selector=selector;let{isLoadable:isLoadable$2,loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$3}=Recoil_Loadable$1,{WrappedValue:WrappedValue$2}=Recoil_Wrapper$1,{peekNodeInfo:peekNodeInfo$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$7,DefaultValue:DefaultValue$2,getConfigDeletionHandler:getConfigDeletionHandler$2,registerNode:registerNode$2,setConfigDeletionHandler:setConfigDeletionHandler$1}=Recoil_Node,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$4,markRecoilValueModified:markRecoilValueModified$2,setRecoilValue:setRecoilValue$4,setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$2}=Recoil_Retention,unwrap=x=>x instanceof WrappedValue$2?x.value:x;function baseAtom(options){var valueOrPromise;let cachedAnswerForUnvalidatedValue;let{key,persistence_UNSTABLE:persistence}=options,retainedBy=retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE),liveStoresCount=0;function unwrapPromise(promise){return loadableWithPromise$2(promise.then(value=>(defaultLoadable=loadableWithValue$3(value),value)).catch(error=>{throw defaultLoadable=loadableWithError$2(error),error}))}let defaultLoadable=Recoil_isPromise(options.default)?unwrapPromise(options.default):isLoadable$2(options.default)?"loading"===options.default.state?unwrapPromise(options.default.contents):options.default:loadableWithValue$3(unwrap(options.default));defaultLoadable.contents;let cleanupEffectsByStore=new Map;function wrapPendingPromise(store,promise){let wrappedPromise=promise.then(value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$4(store,node,value),value}).catch(error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$2(store,node,loadableWithError$2(error)),error});return wrappedPromise}function initAtom(store,initState,trigger){var _options$effects,_cleanupEffectsByStor3,_store$getState$nextT5;liveStoresCount++,store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state&&defaultLoadable.contents.finally(()=>{var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$2(store,node)});let effects=null!==(_options$effects=options.effects)&&void 0!==_options$effects?_options$effects:options.effects_UNSTABLE;if(null!=effects){let initValue=DEFAULT_VALUE$7,isDuringInit=!0,isInitError=!1,pendingSetSelf=null;function getLoadable(recoilValue){if(isDuringInit&&recoilValue.key===key){let retValue=initValue;return retValue instanceof DefaultValue$2?peekAtom(store,initState):Recoil_isPromise(retValue)?loadableWithPromise$2(retValue.then(v=>v instanceof DefaultValue$2?defaultLoadable.toPromise():v)):loadableWithValue$3(retValue)}return getRecoilValueAsLoadable$4(store,recoilValue)}function getPromise(recoilValue){return getLoadable(recoilValue).toPromise()}function getInfo_UNSTABLE(recoilValue){var _store$getState$nextT4;let info=peekNodeInfo$3(store,null!==(_store$getState$nextT4=store.getState().nextTree)&&void 0!==_store$getState$nextT4?_store$getState$nextT4:store.getState().currentTree,recoilValue.key);return!isDuringInit||recoilValue.key!==key||initValue instanceof DefaultValue$2?info:{...info,isSet:!0,loadable:getLoadable(recoilValue)}}let setSelf=effect=>valueOrUpdater=>{if(isDuringInit){let currentLoadable=getLoadable(node),currentValue="hasValue"===currentLoadable.state?currentLoadable.contents:DEFAULT_VALUE$7;Recoil_isPromise(initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater)&&(initValue=initValue.then(value=>(pendingSetSelf={effect,value},value)))}else{if(Recoil_isPromise(valueOrUpdater))throw err_1("Setting atoms to async values is not implemented.");"function"!=typeof valueOrUpdater&&(pendingSetSelf={effect,value:unwrap(valueOrUpdater)}),setRecoilValue$4(store,node,"function"==typeof valueOrUpdater?currentValue=>{let newValue=unwrap(valueOrUpdater(currentValue));return pendingSetSelf={effect,value:newValue},newValue}:unwrap(valueOrUpdater))}},resetSelf=effect=>()=>setSelf(effect)(DEFAULT_VALUE$7),onSet=effect=>handler=>{var _cleanupEffectsByStor2;let{release}=store.subscribeToTransactions(currentStore=>{var _currentTree$atomValu,_previousTree$atomVal,_pendingSetSelf,_pendingSetSelf2,_pendingSetSelf3;let{currentTree,previousTree}=currentStore.getState();previousTree||(recoverableViolation_1("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),previousTree=currentTree);let newLoadable=null!==(_currentTree$atomValu=currentTree.atomValues.get(key))&&void 0!==_currentTree$atomValu?_currentTree$atomValu:defaultLoadable;if("hasValue"===newLoadable.state){let newValue=newLoadable.contents,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$7;(null===(_pendingSetSelf=pendingSetSelf)||void 0===_pendingSetSelf?void 0:_pendingSetSelf.effect)!==effect||(null===(_pendingSetSelf2=pendingSetSelf)||void 0===_pendingSetSelf2?void 0:_pendingSetSelf2.value)!==newValue?handler(newValue,oldValue,!currentTree.atomValues.has(key)):(null===(_pendingSetSelf3=pendingSetSelf)||void 0===_pendingSetSelf3?void 0:_pendingSetSelf3.effect)===effect&&(pendingSetSelf=null)}},key);cleanupEffectsByStore.set(store,[...null!==(_cleanupEffectsByStor2=cleanupEffectsByStore.get(store))&&void 0!==_cleanupEffectsByStor2?_cleanupEffectsByStor2:[],release])};for(let effect of effects)try{let cleanup=effect({node,storeID:store.storeID,parentStoreID_UNSTABLE:store.parentStoreID,trigger,setSelf:setSelf(effect),resetSelf:resetSelf(effect),onSet:onSet(effect),getPromise,getLoadable,getInfo_UNSTABLE});null!=cleanup&&cleanupEffectsByStore.set(store,[...null!==(_cleanupEffectsByStor3=cleanupEffectsByStore.get(store))&&void 0!==_cleanupEffectsByStor3?_cleanupEffectsByStor3:[],cleanup])}catch(error){initValue=error,isInitError=!0}if(isDuringInit=!1,!(initValue instanceof DefaultValue$2)){let initLoadable=isInitError?loadableWithError$2(initValue):Recoil_isPromise(initValue)?loadableWithPromise$2(wrapPendingPromise(store,initValue)):loadableWithValue$3(unwrap(initValue));initLoadable.contents,initState.atomValues.set(key,initLoadable),null===(_store$getState$nextT5=store.getState().nextTree)||void 0===_store$getState$nextT5||_store$getState$nextT5.atomValues.set(key,initLoadable)}}return()=>{var _cleanupEffectsByStor;liveStoresCount--,null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor.forEach(cleanup=>cleanup()),cleanupEffectsByStore.delete(store)}}function peekAtom(_store,state){var _ref,_state$atomValues$get3;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:cachedAnswerForUnvalidatedValue)&&void 0!==_ref?_ref:defaultLoadable}function getAtom(_store,state){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));if(!state.nonvalidatedAtoms.has(key))return defaultLoadable;{if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return expectationViolation_1(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`),defaultLoadable;let nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$7);return cachedAnswerForUnvalidatedValue=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$3(validatorResult)}}function setAtom(_store,state,newValue){if(state.atomValues.has(key)){let existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return new Map}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return new Map;return cachedAnswerForUnvalidatedValue=void 0,new Map().set(key,loadableWithValue$3(newValue))}function shouldDeleteConfigOnReleaseAtom(){return void 0!==getConfigDeletionHandler$2(key)&&liveStoresCount<=0}let node=registerNode$2({key,nodeType:"atom",peek:peekAtom,get:getAtom,set:setAtom,init:initAtom,invalidate:function invalidateAtom(){cachedAnswerForUnvalidatedValue=void 0},shouldDeleteConfigOnRelease:shouldDeleteConfigOnReleaseAtom,dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy});return node}function atom(options){let{...restOptions}=options,optionsDefault="default"in options?options.default:new Promise(()=>{});return isRecoilValue$4(optionsDefault)?atomWithFallback({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}function atomWithFallback(options){let base=atom({...options,default:DEFAULT_VALUE$7,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$7)},effects:options.effects,effects_UNSTABLE:options.effects_UNSTABLE}),sel=Recoil_selector({key:`${options.key}__withFallback`,get:({get})=>{let baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set},newValue)=>set(base,newValue),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:options.dangerouslyAllowMutability});return setConfigDeletionHandler$1(sel.key,getConfigDeletionHandler$2(options.key)),sel}atom.value=value=>new WrappedValue$2(value);var Recoil_atom=atom,Recoil_MapCache$1=Object.freeze({__proto__:null,MapCache:{MapCache:class{constructor(options){var _options$mapKey;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(_options$mapKey=null==options?void 0:options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}size(){return this._map.size}has(key){return this._map.has(this._keyMapper(key))}get(key){return this._map.get(this._keyMapper(key))}set(key,val){this._map.set(this._keyMapper(key),val)}delete(key){this._map.delete(this._keyMapper(key))}clear(){this._map.clear()}}}.MapCache});let{LRUCache:LRUCache$2}=Recoil_LRUCache$1,{MapCache:MapCache$1}=Recoil_MapCache$1,defaultPolicy$1={equality:"reference",eviction:"none",maxSize:1/0};function getValueMapper$1(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw err_1(`Unrecognized equality policy ${equality}`)}function getCache(eviction,maxSize,mapKey){switch(eviction){case"keep-all":return new MapCache$1({mapKey});case"lru":return new LRUCache$2({mapKey,maxSize:Recoil_nullthrows(maxSize)});case"most-recent":return new LRUCache$2({mapKey,maxSize:1})}throw err_1(`Unrecognized eviction policy ${eviction}`)}var Recoil_cacheFromPolicy=function cacheFromPolicy({equality=defaultPolicy$1.equality,eviction=defaultPolicy$1.eviction,maxSize=defaultPolicy$1.maxSize}=defaultPolicy$1){return getCache(eviction,maxSize,getValueMapper$1(equality))};let{setConfigDeletionHandler:setConfigDeletionHandler$2}=Recoil_Node,{setConfigDeletionHandler:setConfigDeletionHandler$3}=Recoil_Node,nextIndex=0;var Recoil_selectorFamily=function selectorFamily(options){var _options$cachePolicyF,_options$cachePolicyF2;let selectorCache=Recoil_cacheFromPolicy({equality:null!==(_options$cachePolicyF=null===(_options$cachePolicyF2=options.cachePolicyForParams_UNSTABLE)||void 0===_options$cachePolicyF2?void 0:_options$cachePolicyF2.equality)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:"value",eviction:"keep-all"});return params=>{var _stableStringify;let cachedSelector,newSelector;try{cachedSelector=selectorCache.get(params)}catch(error){throw err_1(`Problem with cache lookup for selector ${options.key}: ${error.message}`)}if(null!=cachedSelector)return cachedSelector;let myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCachePolicy=options.cachePolicy_UNSTABLE,retainedBy="function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE;if(null!=options.set){let set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy})}else newSelector=Recoil_selector({key:myKey,get:myGet,cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy});return selectorCache.set(params,newSelector),setConfigDeletionHandler$3(newSelector.key,()=>{selectorCache.delete(params)}),newSelector}};let constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cachePolicyForParams_UNSTABLE:{equality:"reference"}}),throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw err_1(message)},cachePolicyForParams_UNSTABLE:{equality:"reference"}}),{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$4}=Recoil_Loadable$1;function concurrentRequests(getRecoilValue,deps){let results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(let[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map(key=>dependencies[key])}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce((out,key,idx)=>({...out,[key]:results[idx]}),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map((exception,idx)=>null==exception?loadableWithValue$4(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)))}function combineAsyncResultsWithSyncResults(syncResults,asyncResults){return asyncResults.map((result,idx)=>void 0===result?syncResults[idx]:result)}let waitForNone=Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get})=>{let[results,exceptions]=concurrentRequests(get,unwrapDependencies(dependencies));return wrapLoadables(dependencies,results,exceptions)},dangerouslyAllowMutability:!0}),waitForAny=Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get})=>{let[results,exceptions]=concurrentRequests(get,unwrapDependencies(dependencies));return exceptions.some(exp=>!Recoil_isPromise(exp))?wrapLoadables(dependencies,results,exceptions):new Promise(resolve=>{for(let[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=result,exceptions[i]=void 0,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,resolve(wrapLoadables(dependencies,results,exceptions))})})},dangerouslyAllowMutability:!0}),waitForAll=Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get})=>{let[results,exceptions]=concurrentRequests(get,unwrapDependencies(dependencies));if(exceptions.every(exp=>null==exp))return wrapResults(dependencies,results);let error=exceptions.find(isError);if(null!=error)throw error;return Promise.all(exceptions).then(exceptionResults=>wrapResults(dependencies,combineAsyncResultsWithSyncResults(results,exceptionResults)))},dangerouslyAllowMutability:!0}),waitForAllSettled=Recoil_selectorFamily({key:"__waitForAllSettled",get:dependencies=>({get})=>{let[results,exceptions]=concurrentRequests(get,unwrapDependencies(dependencies));return exceptions.every(exp=>!Recoil_isPromise(exp))?wrapLoadables(dependencies,results,exceptions):Promise.all(exceptions.map((exp,i)=>Recoil_isPromise(exp)?exp.then(result=>{results[i]=result,exceptions[i]=void 0}).catch(error=>{results[i]=void 0,exceptions[i]=error}):null)).then(()=>wrapLoadables(dependencies,results,exceptions))},dangerouslyAllowMutability:!0}),noWait=Recoil_selectorFamily({key:"__noWait",get:dependency=>({get})=>{try{return Recoil_selector.value(loadableWithValue$4(get(dependency)))}catch(exception){return Recoil_selector.value(Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception))}},dangerouslyAllowMutability:!0}),{RecoilLoadable}=Recoil_Loadable$1,{DefaultValue:DefaultValue$3}=Recoil_Node,{RecoilRoot:RecoilRoot$2,useRecoilStoreID:useRecoilStoreID$1}=Recoil_RecoilRoot,{isRecoilValue:isRecoilValue$5}=Recoil_RecoilValue$1,{retentionZone:retentionZone$1}=Recoil_RetentionZone,{freshSnapshot:freshSnapshot$2}=Recoil_Snapshot$1,{useRecoilState:useRecoilState$1,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilValue:useRecoilValue$1,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,useResetRecoilState:useResetRecoilState$1,useSetRecoilState:useSetRecoilState$1}={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:useRecoilInterface_DEPRECATED,useRecoilState,useRecoilStateLoadable,useRecoilValue,useRecoilValueLoadable,useResetRecoilState,useSetRecoilState,useSetUnvalidatedAtomValues,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,useRecoilState_TRANSITION_SUPPORT_UNSTABLE},{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1}=Recoil_SnapshotHooks,{useRecoilCallback:useRecoilCallback$1}=Recoil_useRecoilCallback,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}={waitForNone,waitForAny,waitForAll,waitForAllSettled,noWait};var Recoil_index={DefaultValue:DefaultValue$3,isRecoilValue:isRecoilValue$5,RecoilLoadable,RecoilEnv:env,RecoilRoot:RecoilRoot$2,useRecoilStoreID:useRecoilStoreID$1,useRecoilBridgeAcrossReactRoots_UNSTABLE:function useRecoilBridgeAcrossReactRoots(){"MUTABLE_SOURCE"===reactMode$4().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");let store=useStoreRef$5().current;return useMemo$2(()=>function RecoilBridge({children}){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecoilRoot$1,{store_INTERNAL:store},children)},[store])},atom:Recoil_atom,selector:Recoil_selector,atomFamily:function atomFamily(options){var _options$cachePolicyF,_options$cachePolicyF2;let atomCache=Recoil_cacheFromPolicy({equality:null!==(_options$cachePolicyF=null===(_options$cachePolicyF2=options.cachePolicyForParams_UNSTABLE)||void 0===_options$cachePolicyF2?void 0:_options$cachePolicyF2.equality)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:"value",eviction:"keep-all"});return params=>{var _stableStringify,_options$effects;let cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;let{cachePolicyForParams_UNSTABLE,...atomOptions}=options,optionsDefault="default"in options?options.default:new Promise(()=>{}),newAtom=Recoil_atom({...atomOptions,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:"function"==typeof optionsDefault?optionsDefault(params):optionsDefault,retainedBy_UNSTABLE:"function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE,effects:"function"==typeof options.effects?options.effects(params):"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):null!==(_options$effects=options.effects)&&void 0!==_options$effects?_options$effects:options.effects_UNSTABLE});return atomCache.set(params,newAtom),setConfigDeletionHandler$2(newAtom.key,()=>{atomCache.delete(params)}),newAtom}},selectorFamily:Recoil_selectorFamily,constSelector:function constSelector(constant){return constantSelector(constant)},errorSelector:function errorSelector(message){return throwingSelector(message)},readOnlySelector:function readOnlySelector(atom){return atom},noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useGetRecoilValueInfo_UNSTABLE:function useGetRecoilValueInfo(){let storeRef=useStoreRef$4();return({key})=>peekNodeInfo$2(storeRef.current,storeRef.current.getState().currentTree,key)},useRecoilRefresher_UNSTABLE:function useRecoilRefresher(recoilValue){let storeRef=useStoreRef$7();return useCallback$4(()=>{refreshRecoilValue$2(storeRef.current,recoilValue)},[recoilValue,storeRef])},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilCallback:useRecoilCallback$1,useRecoilTransaction_UNSTABLE:function useRecoilTransaction(fn,deps){let storeRef=useStoreRef$8();return useMemo$3(()=>(...args)=>{atomicUpdater$2(storeRef.current)(transactionInterface=>{fn(transactionInterface)(...args)})},null!=deps?[...deps,storeRef]:void 0)},useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,snapshot_UNSTABLE:freshSnapshot$2,useRetain:Recoil_useRetain,retentionZone:retentionZone$1};Recoil_index.DefaultValue,Recoil_index.isRecoilValue,Recoil_index.RecoilLoadable,Recoil_index.RecoilEnv;var Recoil_index_5=Recoil_index.RecoilRoot;Recoil_index.useRecoilStoreID,Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;var Recoil_index_8=Recoil_index.atom;Recoil_index.selector,Recoil_index.atomFamily,Recoil_index.selectorFamily,Recoil_index.constSelector,Recoil_index.errorSelector,Recoil_index.readOnlySelector,Recoil_index.noWait,Recoil_index.waitForNone,Recoil_index.waitForAny,Recoil_index.waitForAll,Recoil_index.waitForAllSettled;var Recoil_index_20=Recoil_index.useRecoilValue;Recoil_index.useRecoilValueLoadable;var Recoil_index_22=Recoil_index.useRecoilState;Recoil_index.useRecoilStateLoadable,Recoil_index.useSetRecoilState,Recoil_index.useResetRecoilState,Recoil_index.useGetRecoilValueInfo_UNSTABLE,Recoil_index.useRecoilRefresher_UNSTABLE,Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,Recoil_index.useRecoilCallback,Recoil_index.useRecoilTransaction_UNSTABLE,Recoil_index.useGotoRecoilSnapshot,Recoil_index.useRecoilSnapshot,Recoil_index.useRecoilTransactionObserver_UNSTABLE,Recoil_index.snapshot_UNSTABLE,Recoil_index.useRetain,Recoil_index.retentionZone}}]);
//# sourceMappingURL=444.fe1f8b0c.iframe.bundle.js.map